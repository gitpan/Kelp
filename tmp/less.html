<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#TITLE">TITLE</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#QUICK-START">QUICK START</a></li>
  <li><a href="#KEYWORDS">KEYWORDS</a>
    <ul>
      <li><a href="#app">app</a></li>
      <li><a href="#attr">attr</a></li>
      <li><a href="#route">route</a></li>
      <li><a href="#get-post-put">get, post, put</a></li>
      <li><a href="#param">param</a></li>
      <li><a href="#stash">stash</a></li>
      <li><a href="#named">named</a></li>
      <li><a href="#req">req</a></li>
      <li><a href="#res">res</a></li>
      <li><a href="#template">template</a></li>
      <li><a href="#run">run</a></li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#CREDITS">CREDITS</a></li>
  <li><a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></li>
  <li><a href="#LICENSE">LICENSE</a></li>
</ul>

<h1 id="TITLE">TITLE</h1>

<p>Kelp::Less - Quick prototyping with Kelp</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    use Kelp::Less;

    get &#39;/person/:name&#39; =&gt; sub {
        &quot;Hello &quot; . named &#39;name&#39;;
    };

    run;</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This modules exists to provide a way for quick and sloppy prototyping of a web application. It is a wrapper for <a>Kelp</a>, which imports several keywords, making it easier and less verbose to create a quick web app.</p>

<p>It&#39;s called <code>Less</code>, because there is less typing involved with it, and also because it is suited for smaller, less complicated web projects. We encourage you to use it anywhere you see fit, however for mid-size and big applications we recomend that you use the fully structured <a>Kelp</a>. This way you can take advantage of the powerful router and initialization.</p>

<h1 id="QUICK-START">QUICK START</h1>

<p>Each web app begins with <code>use Kelp::Less;</code>. It automatically imports <code>strict</code>, <code>warnings</code>, <code>v5.10</code> as well as several useful functions. You can pass any parameters to the constructor at the <code>use</code> statement:</p>

<pre><code>    use Kelp::Less mode =&gt; &#39;development&#39;;</code></pre>

<p>The above is equivalent to:</p>

<pre><code>    use Kelp;
    my $app = Kelp-&gt;new( mode =&gt; &#39;development&#39; );</code></pre>

<p>After that, you could add any initializations and attributes. For example, connect to a database or setup cache. <code>Kelp::Less</code> exports <a>attr</a>, so you can use it to register attributes to your app.</p>

<pre><code>    # Connect to DBI and CHI right away
    attr dbh   =&gt; DBI-&gt;connect(...);
    attr cache =&gt; CHI-&gt;new(...);

    # Lazy attribute. The code will be executed when app-&gt;version is called.
    attr version =&gt; sub {
        app-&gt;dbh-&gt;selectrow_array(&quot;SELECT version FROM vars&quot;);
    };

    # Later:
    app-&gt;dbh-&gt;do(...);
    app-&gt;cache-&gt;get(...);
    if ( app-&gt;version ) { ... }</code></pre>

<p>Now is a good time to add routes. Routes are added via the <a href="#route">&quot;route&quot;</a> keyword and they are automatically registered in your app. A route needs to parameters - <code>path</code> and <code>destination</code>. These are exactly equivalent to <a>&quot;add&quot; in Kelp::Routes</a>, and you are encouraged to read its POD to get familiar with how to add routes. Here are a few examples for the impatient:</p>

<pre><code>    # Add a &#39;catch-all methods&#39; route and send it to an anonymous sub
    route &#39;/hello/:name&#39; =&gt; sub {
        return &quot;Hello &quot; . named(&#39;name&#39;);
    };

    # Add a POST route
    route [ POST =&gt; &#39;/edit/:id&#39; ] =&gt; sub {
        # Do something with named(&#39;id&#39;)
    };

    # Route that runs an existing sub in your code
    route &#39;/login&#39; =&gt; &#39;login&#39;;
    sub login {
        ...
    }</code></pre>

<p>Each route subroutine receives <code>$self</code> and all named placeholders, so one could use them, if it makes it easier to understand where it all comes from.</p>

<pre><code>    route &#39;/:id/:page&#39; =&gt; sub {
        my ( $self, $id, $page ) = @_;
    };</code></pre>

<p>Here, <code>$self</code> is the app object and it can be used the same way as in a full <a>Kelp</a> route. For the feeling of magic and eeriness, <code>Kelp::Lite</code> aliases <code>app</code> to <code>$self</code>, so the former can be used as a full substitute to the latter. See the exported keywords section for more information.</p>

<p>After you have added all of your routes, it is time to run the app. This is done via a single command:</p>

<pre><code>    run;</code></pre>

<p>It returns PSGI ready structure, so you can immediately deploy your new app via Plack:</p>

<pre><code>    % plackup myapp.psgi
    HTTP::Server::PSGI: Accepting connections at http://0:5000/</code></pre>

<h1 id="KEYWORDS">KEYWORDS</h1>

<p>The following list of keywords are exported to allow for less typing in <code>Kelp::Less</code>:</p>

<h2 id="app">app</h2>

<p>This a full alias for <code>$self</code>. It is the application object, and an instance of the <code>Kelp</code> class. You can use it for anything you would use <code>$self</code> inside a route.</p>

<pre><code>    route &#39;/yo&#39; =&gt; sub {
        app-&gt;res-&gt;code(500);
    };</code></pre>

<h2 id="attr">attr</h2>

<p>Assigns lazy or active attributes (using <a>Kelp::Base</a>) to <code>app</code>. Use it to initialize your application.</p>

<pre><code>    attr mongo =&gt; MongoDB::MongoClient-&gt;new( ... );</code></pre>

<h2 id="route">route</h2>

<p>Adds a route to <code>app</code>. It is an alias to <code>$self-</code>routes-&gt;add&gt;, and requires the exact same parameters. See <a>Kelp::Routes</a> for enlightenment.</p>

<pre><code>    route &#39;/get&#39; =&gt; sub { &quot;got&quot; };</code></pre>

<h2 id="get-post-put">get, post, put</h2>

<p>These are shortcuts to <code>route</code> restricted to the corresponding HTTP method.</p>

<pre><code>    get &#39;/data&#39;  =&gt; sub { &quot;Only works with GET&quot; };
    post &#39;/data&#39; =&gt; sub { &quot;Only works with POST&quot; };
    put &#39;/data&#39;  =&gt; sub { &quot;Only works with PUT&quot; };</code></pre>

<h2 id="param">param</h2>

<p>An alias for <code>$self-&gt;param</code> that gets the GET or POST parameters. When used with no arguments, it will return an array with the names of all http parameters. Otherwise, it will return the value of the requested http parameter.</p>

<pre><code>    get &#39;/names&#39; =&gt; sub {
        my @names = param;
        # Now @names contains the names of the params
    };

    get &#39;/value&#39; =&gt; sub {
        my $id = param &#39;id&#39;;
        # Now $is contains the value of &#39;id&#39;
    };</code></pre>

<h2 id="stash">stash</h2>

<p>An alias for <code>$self-&gt;stash</code>. The stash is a concept originally conceived by the developers of <a>Catalyst</a>. It&#39;s a hash that you can use to pass data from one route to another.</p>

<pre><code>    # Create a bridge route that checks if the user is authenticated, and saves
    # the username in the stash.
    get &#39;/user&#39; =&gt; { bridge =&gt; 1, to =&gt; sub {
        return stash-&gt;{username} = app-&gt;authenticate();
    }};

    # This route is run after the above bridge, so we know that we have an
    # authenticated user and their username in the stash.
    get &#39;/user/welcome&#39; =&gt; sub {
        return &quot;Hello &quot; . stash &#39;username&#39;;
    };</code></pre>

<p>With no arguments <code>stash</code> returns the entire stash hash. A single argument is interpreted as the key to the stash hash and its value is returned accordingly.</p>

<h2 id="named">named</h2>

<p>An alias for <code>$self-&gt;named</code>. The <code>named</code> hash contains the names and values of the named placeholders from the current route&#39;s path. Much like the <code>stash</code>, with no arguments it returns the entire <code>named</code> hash, and with a single argument it returns the value for the corresponding key in the hash.</p>

<pre><code>    get &#39;/:name/:id&#39; =&gt; sub {
        my $name = named &#39;name&#39;;
        my $id = name &#39;id&#39;;
    };</code></pre>

<p>In the above example a GET request to <code>/james/1000</code> will initialize <code>$name</code> with <code>&quot;james&quot;</code> and <code>$id</code> with <code>1000</code>.</p>

<h2 id="req">req</h2>

<p>An alias for <code>$self-&gt;req</code>, this provides quick access to the <a>Kelp::Request</a> object for the current route.</p>

<pre><code>    # Inside a route
    if ( req-&gt;is_ajax ) {
        ...
    }</code></pre>

<h2 id="res">res</h2>

<p>An alias for <code>$self-&gt;res</code>, this is a shortcut for the <a>Kelp::Response</a> object for the current route.</p>

<pre><code>    # Inside a route
    res-&gt;code(403);
    res-&gt;json-&gt;render({ message =&gt; &quot;Forbidden&quot; });</code></pre>

<h2 id="template">template</h2>

<p>A shortcut to <code>$self-&gt;res-&gt;template</code>. Renders a template using the currently loaded template module.</p>

<pre><code>    get &#39;/hello/:name&#39; =&gt; sub {
        template &#39;hello.tt&#39;, { name =&gt; named &#39;name&#39; };
    };</code></pre>

<h2 id="run">run</h2>

<p>Creates and returns a PSGI readu subroutine, and makes the app ready for <code>Plack</code>.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a>Kelp</a></p>

<h1 id="CREDITS">CREDITS</h1>

<p>Author: minimalist - minimal@cpan.org</p>

<h1 id="ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</h1>

<p>This module&#39;s interface was inspired by <a>Dancer</a>.</p>

<h1 id="LICENSE">LICENSE</h1>

<p>Same as Perl itself.</p>


</body>

</html>


