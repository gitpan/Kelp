<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">




</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">




</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">




</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">




</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">




</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">




</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">




</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">




</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">




</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Kelp::Less - Quick prototyping with Kelp</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Please refer to the manual at <a>Kelp::Manual::Less</a></p>


</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#WHY-KELP-">WHY KELP?</a></li>
  <li><a href="#CREATING-A-NEW-WEB-APP">CREATING A NEW WEB APP</a>
    <ul>
      <li><a href="#Using-the-Kelp-script">Using the <code>Kelp</code> script</a></li>
      <li><a href="#Directory-structure">Directory structure</a></li>
      <li><a href="#The-application-classes">The application classes</a></li>
      <li><a href="#Routing">Routing</a>
        <ul>
          <li><a href="#Destinations">Destinations</a></li>
          <li><a href="#Restrict-HTTP-methods">Restrict HTTP methods</a></li>
          <li><a href="#Named-captures">Named captures</a>
            <ul>
              <li><a href="#Explicit">Explicit</a></li>
              <li><a href="#Optional">Optional</a></li>
              <li><a href="#Wildcards">Wildcards</a></li>
            </ul>
          </li>
          <li><a href="#Placeholder-restrictions">Placeholder restrictions</a></li>
          <li><a href="#Placeholder-defaults">Placeholder defaults</a></li>
          <li><a href="#Bridges">Bridges</a></li>
          <li><a href="#URL-building">URL building</a></li>
        </ul>
      </li>
      <li><a href="#Quick-development-using-Kelp::Less">Quick development using Kelp::Less</a></li>
      <li><a href="#Adding-middleware">Adding middleware</a>
        <ul>
          <li><a href="#Using-the-configuration">Using the configuration</a></li>
          <li><a href="#In-app.psgi:">In <code>app.psgi</code>:</a></li>
          <li><a href="#By-overriding-the-run-subroutine-in-lib-MyApp.pm:">By overriding the <a href="#run">&quot;run&quot;</a> subroutine in <code>lib/MyApp.pm</code>:</a></li>
        </ul>
      </li>
      <li><a href="#Deploying">Deploying</a></li>
      <li><a href="#Testing">Testing</a></li>
      <li><a href="#Building-an-HTTP-response">Building an HTTP response</a>
        <ul>
          <li><a href="#Automatic-content-type">Automatic content type</a></li>
          <li><a href="#Rendering-text">Rendering text</a></li>
          <li><a href="#Rendering-HTML">Rendering HTML</a></li>
          <li><a href="#Custom-content-type">Custom content type</a></li>
          <li><a href="#Return-404-or-500-errors">Return 404 or 500 errors</a></li>
          <li><a href="#Templates">Templates</a></li>
          <li><a href="#Headers">Headers</a></li>
          <li><a href="#Delayed-responses">Delayed responses</a></li>
        </ul>
      </li>
      <li><a href="#Pluggable-modules">Pluggable modules</a>
        <ul>
          <li><a href="#How-to-load-modules-using-the-config">How to load modules using the config</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#ATTRIBUTES">ATTRIBUTES</a>
    <ul>
      <li><a href="#hostname">hostname</a></li>
      <li><a href="#mode">mode</a></li>
      <li><a href="#path">path</a></li>
      <li><a href="#name">name</a></li>
      <li><a href="#charset">charset</a></li>
      <li><a href="#req">req</a></li>
      <li><a href="#res">res</a></li>
    </ul>
  </li>
  <li><a href="#METHODS">METHODS</a>
    <ul>
      <li><a href="#build">build</a></li>
      <li><a href="#load_module">load_module</a></li>
      <li><a href="#request">request</a></li>
      <li><a href="#before_render">before_render</a></li>
      <li><a href="#response">response</a></li>
      <li><a href="#run">run</a></li>
      <li><a href="#param">param</a></li>
      <li><a href="#stash">stash</a></li>
      <li><a href="#named">named</a></li>
      <li><a href="#url_for">url_for</a></li>
    </ul>
  </li>
</ul>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p>First ...</p>

<pre><code>    # lib/MyApp.pm
    package MyApp;
    use parent &#39;Kelp&#39;;

    sub build {
        my $self = shift;
        my $r = $self-&gt;routes;
        $r-&gt;add( &quot;/hello&quot;, sub { &quot;Hello, world!&quot; } );
        $r-&gt;add( &#39;/hello/:name&#39;, &#39;greet&#39; );
    }

    sub greet {
        my ( $self, $name ) = @_;
        &quot;Hello, $name!&quot;;
    }

    1;</code></pre>

<p>Then ...</p>

<pre><code>    # app.psgi
    use MyApp;
    my $app = MyApp-&gt;new;
    $app-&gt;run;</code></pre>

<p>Finally ...</p>

<pre><code>    &gt; plackup app.psgi</code></pre>

<p>Or, for quick prototyping use <a>Kelp::Less</a>:</p>

<pre><code>    # app.psgi
    use Kelp::Less;

    get &#39;/hello/?name&#39; =&gt; sub {
        my ( $self, $name ) = @_;
        &quot;Hello &quot; . $name // &#39;world&#39;;
    };

    run;</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>If you&#39;re going to be deploying a Perl based web application, chances are that you will be using Plack. Plack has almost all necessary tools to create and maintain a healthy web app. Tons of middleware is written for it, and there are several very well tested high performance preforking servers, such as Starman.</p>

<p>Plack, however, is not a web framework, hence its creators have intentionally omitted adding certain components. This is where Kelp gets to shine. It provides a layer on top of Plack and puts everything together into a complete web framework.</p>

<p>Kelp provides:</p>

<ul>

<li><p><b>Advanced Routing</b>. Create intricate, yet simple ways to capture HTTP requests and route them to their designated code. Use explicit and optional named placeholders, wildcards, or just regular expressions.</p>

</li>
<li><p><b>Flexible Configuration</b>. Use different configuration file for each environment, e.g. development, deployment, etc. Merge a temporary configuration into your current one for testing and debugging purposes.</p>

</li>
<li><p><b>Enhanced Logging</b>. Log messages at different levels of emergency. Log to a file, screen, or anything supported by Log::Dispatcher.</p>

</li>
<li><p><b>Powerful Rendering</b>. Use the built-in auto-rendering logic, or the template module of your choice to return rich text, html and JSON responses.</p>

</li>
<li><p><b>JSON encoder/decoder</b>. If you&#39;re serious about your back-end code. Kelp comes with JSON, but you can easily plug in JSON::XS or any decoder of your choice.</p>

</li>
<li><p><b>Extendable Core</b>. Kelp uses pluggable modules for everything. This allows anyone to add a module for a custom interface. Writing Kelp modules is a pleasant and fulfilling activity.</p>

</li>
<li><p><b>Sleek Testing</b>. Kelp takes Plack::Test and wraps it in an object oriented class of convenience methods. Testing is done via sending requests to your routes, then analyzing the response.</p>

</li>
</ul>

<h1 id="WHY-KELP-">WHY KELP?</h1>

<p>What makes Kelp different from the other Perl micro web frameworks? There are a number of fine web frameworks on CPAN, and most of them provide a complete platform for web app building. Most of them, however, bring their deployment code, and aim to write their own processing mechanisms. Kelp, on the other hand, is heavily <i>Plack</i>-centric. It uses Plack as its foundation layer, and it builds the web framework on top of it. <code>Kelp::Request</code> is an extension of <code>Plack::Request</code>, <code>Kelp::Response</code> is an extension of <code>Plack::Response</code>.</p>

<p>This approach of extending current CPAN code puts familiar and well tested tools in the hands of the application developer, while keeping familiar syntax and work flow.</p>

<p>Kelp is a team player and it uses several popular, trusted CPAN modules for its internals. At the same time it doesn&#39;t include modules that it doesn&#39;t need, just because they are considered trendy. It does its best to keep a lean profile and a small footprint, and it&#39;s completely object manager agnostic.</p>

<h1 id="CREATING-A-NEW-WEB-APP">CREATING A NEW WEB APP</h1>

<h2 id="Using-the-Kelp-script">Using the <code>Kelp</code> script</h2>

<p>The easiest way to create the directory structure and a general application skeleton is by using the <code>Kelp</code> script, which comes with this package.</p>

<pre><code>    &gt; Kelp MyApp</code></pre>

<p>This will create <code>lib/MyApp.pm</code>, <code>app.psgi</code> and some other files (explained below).</p>

<p>To create a <a>Kelp::Less</a> app, use:</p>

<pre><code>    &gt; Kelp --less MyApp</code></pre>

<p>Get help by typing:</p>

<pre><code>    &gt; Kelp --help</code></pre>

<h2 id="Directory-structure">Directory structure</h2>

<p>Before you begin writing the internals of your app, you need to create the directory structure either by hand, or by using the above described <code>Kelp</code> utility script.</p>

<pre><code>     .
     |--/lib
     |   |--MyApp.pm
     |   |--/MyApp
     |
     |--/conf
     |   |--config.pl
     |   |--config_test.pl
     |   |--config_deployment.pl
     |
     |--/view
     |--/log
     |--/t
     |--app.psgi</code></pre>

<dl>

<dt id="lib"><b>/lib</b></dt>
<dd>

<p>The <code>lib</code> folder contains your application modules and any local modules that you want your app to use.</p>

</dd>
<dt id="conf"><b>/conf</b></dt>
<dd>

<p>The <code>conf</code> folder is where Kelp will look for configuration files. You need one main file, named <code>config.pl</code>. You can also add other files that define different running environments, if you name them <code>config_</code><i>environment</i><code>.pl</code>. Replace <i>environment</i> with the actual name of the environment. To change the running environment, you can specify the app <code>mode</code>, or you can set the <code>KELP_ENV</code> environment variable.</p>

<pre><code>    my $app = MyApp-&gt;new( mode =&gt; &#39;development&#39; );</code></pre>

<p>or</p>

<pre><code>    &gt; PLACK_ENV=development plackup app.psgi</code></pre>

</dd>
<dt id="view"><b>/view</b></dt>
<dd>

<p>This is where the <code>Template</code> module will look for template files.</p>

</dd>
<dt id="log"><b>/log</b></dt>
<dd>

<p>This is where the <code>Logger</code> module will create <code>error.log</code>, <code>debug.log</code> and any other log files that were defined in the configuration.</p>

</dd>
<dt id="t"><b>/t</b></dt>
<dd>

<p>The <code>t</code> folder is traditionally used to hold test files. It is up to you to use it or not, although we strongly recommend that you write some automated test units for your web app.</p>

</dd>
<dt id="app.psgi"><b>app.psgi</b></dt>
<dd>

<p>This is the <a>PSGI</a> file, of the app, which you will deploy. In it&#39;s most basic form it should look like this:</p>

<pre><code>    use lib &#39;../lib&#39;;
    use MyApp;

    my $app = MyApp-&gt;new;
    $app-&gt;run;</code></pre>

</dd>
</dl>

<h2 id="The-application-classes">The application classes</h2>

<p>Your application&#39;s classes should be put in the <code>lib/</code> folder. The main class, in our example <code>MyApp.pm</code>, initializes any modules and variables that your app will use. Here is an example that uses <code>Moose</code> to create lazy attributes and initialize a database connection:</p>

<pre><code>    package MyApp;
    use Moose;

    has dbh =&gt; (
        is      =&gt; &#39;ro&#39;,
        isa     =&gt; &#39;DBI&#39;,
        lazy    =&gt; 1,
        default =&gt; sub {
            my $self   = shift;
            my @config = @{ $self-&gt;config(&#39;dbi&#39;) };
            return DBI-&gt;connect(@config);
        }
    );

    sub build {
        my $self = shift;
        $self-&gt;routes-&gt;add(&quot;/read/:id&quot;, &quot;read&quot;);
    }

    sub read {
        my ( $self, $id ) = @_;
        $self-&gt;dbh-&gt;selectrow_array(q[
            SELECT * FROM problems
            WHERE id = ?
        ], $id);
    }

    1;</code></pre>

<p>What is happening here?</p>

<ul>

<li><p>First, we create a lazy attribute and instruct it to connect to DBI. Notice that we have access to the current app and all of its internals via the <code>$self</code> variable. Notice also that the reason we define <code>dbh</code> as a <i>lazy</i> attribute is that <code>config</code> will not yet be initialized. All modules are initialized upon the creation of the object instance, e.g. when we call <code>MyApp-&gt;new</code>;</p>

</li>
<li><p>Then, we override Kelp&#39;s <a href="#build">&quot;build&quot;</a> subroutine to create a single route <code>/read/:id</code>, which is assigned to the subroutine <code>read</code> in the current class.</p>

</li>
<li><p>The <code>read</code> subroutine, takes <code>$self</code> and <code>$id</code> (the named placeholder from the path), and uses <code>$self-&gt;dbh</code> to retrieve data.</p>

</li>
</ul>

<p><i>A note about object managers:</i> The above example uses <a>Moose</a>. It is entirely up to you to use Moose, another object manager, or no object manager at all. The above example will be just as successful if you used our own little <a>Kelp::Base</a>:</p>

<pre><code>    package MyApp;
    use Kelp::Base &#39;Kelp&#39;;

    attr dbi =&gt; sub {
        ...
    };

    1;</code></pre>

<h2 id="Routing">Routing</h2>

<p>Kelp uses a powerful and very flexible router. Traditionally, it is also light and consists of less than 300 lines of loose code (commends included). You are encouraged to read <a>Kelp::Routes</a>, but here are some key points. All examples are assumed to be inside the <a href="#build">&quot;build&quot;</a> method and <code>$r</code> is equal to <code>$self-&gt;routes</code>:</p>

<h3 id="Destinations">Destinations</h3>

<p>You can direct HTTP paths to subroutines in your classes or, you can use inline code.</p>

<pre><code>    $r-&gt;add( &quot;/home&quot;, &quot;home&quot; );  # goes to sub home
    $r-&gt;add( &quot;/legal&quot;, &quot;legal#view&quot; ); # goes to MyApp::Legal::view
    $r-&gt;add( &quot;/about&quot;, sub { &quot;Content for about&quot; }); # inline</code></pre>

<h3 id="Restrict-HTTP-methods">Restrict HTTP methods</h3>

<p>Make a route only catch a specific HTTP method:</p>

<pre><code>    $r-&gt;add( [ POST =&gt; &#39;/update&#39; ], &quot;update_user&quot; );</code></pre>

<h3 id="Named-captures">Named captures</h3>

<p>Using regular expressions is so Perl. Sometimes, however, it gets a little overwhelming. Use named paths if you anticipate that you or someone else will ever want to maintain your code.</p>

<h4 id="Explicit">Explicit</h4>

<pre><code>    $r-&gt;add( &quot;/update/:id&quot;, &quot;update&quot; );

    # Later
    sub update {
        my ( $self, $id ) = @_;
        # Do something with $id
    }</code></pre>

<h4 id="Optional">Optional</h4>

<pre><code>    $r-&gt;add( &quot;/person/?name&quot;, sub {
        my ( $self, $name ) = @_;
        return &quot;I am &quot; . $name // &quot;nobody&quot;;
    });</code></pre>

<p>This will handle <code>/person</code>, <code>/person/</code> and <code>/person/jack</code>.</p>

<h4 id="Wildcards">Wildcards</h4>

<pre><code>    $r-&gt;add( &#39;/*article/:id&#39;, &#39;articles#view&#39; );</code></pre>

<p>This will handle <code>/bar/foo/baz/500</code> and send it to <code>MyApp::Articles::view</code> with parameters <code>$article</code> equal to <code>bar/foo/baz</code> and <code>$id</code> equal to 500.</p>

<h3 id="Placeholder-restrictions">Placeholder restrictions</h3>

<p>Paths&#39; named placeholders can be restricted by providing regular expressions.</p>

<pre><code>    $r-&gt;add( &#39;/user/:id&#39;, {
        check =&gt; { id =&gt; &#39;\d+&#39; },
        to    =&gt; &quot;users#get&quot;
    });

    # Matches /user/1000, but not /user/abc</code></pre>

<h3 id="Placeholder-defaults">Placeholder defaults</h3>

<p>This only applies to optional placeholders, or those prefixed with a question mark. If a default value is provided for any of them, it will be used in case the placeholder value is missing.</p>

<pre><code>    $r-&gt;add( &#39;/:id/?other&#39;, defaults =&gt; { other =&gt; &#39;info&#39; } );

    # GET /100;
    # { id =&gt; 100, other =&gt; &#39;info&#39; }

    # GET /100/delete;
    # { id =&gt; 100, other =&gt; &#39;delete&#39; }</code></pre>

<h3 id="Bridges">Bridges</h3>

<p>A <i>bridge</i> is a route that has to return a true value in order for the next route in line to be processed.</p>

<pre><code>    $r-&gt;add( &#39;/users&#39;, { to =&gt; &#39;Users::auth&#39;, bridge =&gt; 1 } );
    $r-&gt;add( &#39;/users/:action&#39; =&gt; &#39;Users::dispatch&#39; );</code></pre>

<p>See <a>&quot;BRIDGES&quot; in Kelp::Routes</a> for more information.</p>

<h3 id="URL-building">URL building</h3>

<p>Each path can be given a name and later a URL can be built using that name and the necessary arguments.</p>

<pre><code>    $r-&gt;add( &quot;/update/:id&quot;, { name =&gt; &#39;update&#39;, to =&gt; &#39;user#update&#39; } );

    # Later

    my $url = $self-&gt;route-&gt;url(&#39;update&#39;, id =&gt; 1000); # /update/1000</code></pre>

<h2 id="Quick-development-using-Kelp::Less">Quick development using Kelp::Less</h2>

<p>For writing quick experimental web apps and to reduce the boiler plate, one could use <a>Kelp::Less</a>. In this case all of the code can be put in <code>app.psgi</code>: Look up the POD for <code>Kelp::Less</code> for many examples, but to get you started off, here is a quick one:</p>

<pre><code>    # app.psgi
    use Kelp:::Less;

    get &#39;/api/:user/?action&#39; =&gt; sub {
        my ( $self, $user, $action ) = @_;
        my $json = {
            success =&gt; \1,
            user    =&gt; $user,
            action  =&gt; $action // &#39;ask&#39;
        };
        return $json;
    };

    run;</code></pre>

<h2 id="Adding-middleware">Adding middleware</h2>

<p>Kelp, being Plack-centric, will let you easily add middleware. There are three possible ways to add middleware to your application, and all three ways can be used separately or together.</p>

<h3 id="Using-the-configuration">Using the configuration</h3>

<p>Adding middleware in your configuration is probably the easiest and best way for you. This way you can load different middleware for each running mode, e.g. <code>Debug</code> in development only.</p>

<p>Add middleware names to the <code>middleware</code> array in your configuration file and the corresponding initializing arguments in the <code>middleware_init</code> hash:</p>

<pre><code>    # conf/config_development.pl
    {
        middleware      =&gt; [qw/Session Debug/],
        middleware_init =&gt; {
            Session =&gt; { store =&gt; &#39;File&#39; }
        }
    }</code></pre>

<p>The middleware will be added in the order you specify in the <code>middleware</code> array.</p>

<h3 id="In-app.psgi:">In <code>app.psgi</code>:</h3>

<pre><code>    # app.psgi
    use MyApp;
    use Plack::Builder;

    my $app = MyApp-&gt;new();

    builder {
        enable &quot;Plack::Middleware::ContentLength&quot;;
        $app-&gt;run;
    };</code></pre>

<h3 id="By-overriding-the-run-subroutine-in-lib-MyApp.pm:">By overriding the <a href="#run">&quot;run&quot;</a> subroutine in <code>lib/MyApp.pm</code>:</h3>

<p>Make sure you call <code>SUPER</code> first, and then wrap new middleware around the returned app.</p>

<pre><code>    # lib/MyApp.pm
    sub run {
        my $self = shift;
        my $app = $self-&gt;SUPER::run(@_);
        Plack::Middleware::ContentLength-&gt;wrap($app);
    }</code></pre>

<p>Note that any middleware defined in your config file will be added first.</p>

<h2 id="Deploying">Deploying</h2>

<p>Deploying a Kelp application is done the same way any other Plack application is deployed:</p>

<pre><code>    &gt; plackup -E deployment -s Starman app.psgi</code></pre>

<h2 id="Testing">Testing</h2>

<p>Kelp provides a test class called <code>Kelp::Test</code>. It is object oriented, and all methods return the <code>Kelp::Test</code> object, so they can be chained together. Testing is done by sending HTTP requests to an already built application and analyzing the response. Therefore, each test usually begins with the <a>&quot;request&quot; in Kelp::Test</a> method, which takes a single <a>HTTP::Request</a> parameter. It sends the request to the web app and saves the response as an <a>HTTP::Response</a> object.</p>

<pre><code>    # file t/test.t
    use MyApp;
    use Kelp::Test;
    use Test::More;
    use HTTP::Request::Common;

    my $app = MyApp-&gt;new( mode =&gt; &#39;test&#39; );
    my $t = Kelp::Test-&gt;new( app =&gt; $app );

    $t-&gt;request( GET &#39;/path&#39; )
      -&gt;code_is(200)
      -&gt;content_is(&quot;It works&quot;);

    $t-&gt;request( POST &#39;/api&#39; )
      -&gt;json_cmp({auth =&gt; 1});

    done_testing;</code></pre>

<p>What is happening here?</p>

<ul>

<li><p>First, we create an instance of the web application class, which we have previously built and placed in the <code>lib/</code> folder. We set the mode of the app to <code>test</code>, so that file <code>conf/config_test.pl</code> overrides the main configuration. The test configuration can contain anything you see fit. Perhaps you want to disable certain modules, or maybe you want to make DBI connect to a different database.</p>

</li>
<li><p>Second, we create an instance of the <code>Kelp::Test</code> class and tell it that it will perform all tests using our <code>$app</code> instance.</p>

</li>
<li><p>At this point we are ready to send requests to the app via the <a>request</a> method. It takes only one argument, an HTTP::Request object. It is very convenient to use the <a>HTTP::Request::Common</a> module here, because you can create common requests using abridged syntax, i.e. <code>GET</code>, <code>POST</code>, etc. The line <code>$t-&gt;request( GET &#39;/path&#39; )</code> fist creates a HTTP::Request GET object, and then passes it to the <code>request</code> method.</p>

</li>
<li><p>After we send the request, we can test the response using any of the <code>Test::</code> modules, or via the methods provided by <a>Kelp::Test</a>. In the above example, we test if we got a code 200 back from <code>/path</code> and if the returned content was <code>It works</code>.</p>

</li>
</ul>

<p>Run the rest as usual, using <code>prove</code>:</p>

<pre><code>    &gt; prove -l t/test.t</code></pre>

<p>Take a look at the <a>Kelp::Test</a> for details and more examples.</p>

<h2 id="Building-an-HTTP-response">Building an HTTP response</h2>

<p>Kelp contains an elegant module, called <a>Kelp::Response</a>, which extends <code>Plack::Response</code> with several useful methods. Most methods return <code>$self</code> after they do the required job. For the sake of the examples below, let&#39;s assume that all of the code is located inside a route definition.</p>

<h3 id="Automatic-content-type">Automatic content type</h3>

<p>Your routes don&#39;t always have to set the <code>response</code> object. You could just return a simple scalar value or a reference to a hash, array or anything that can be converted to JSON.</p>

<pre><code>    # Content-type automatically set to &quot;text/html&quot;
    sub text_route {
        return &quot;There, there ...&quot;;
    }

    # Content-type automatically set to &quot;application/json&quot;
    sub json_route {
        return { error =&gt; 1,  message =&gt; &quot;Fail&quot; };
    }</code></pre>

<h3 id="Rendering-text">Rendering text</h3>

<pre><code>    # Render simple text
    $self-&gt;res-&gt;text-&gt;render(&quot;It works!&quot;);</code></pre>

<h3 id="Rendering-HTML">Rendering HTML</h3>

<pre><code>    $self-&gt;res-&gt;html-&gt;render(&quot;&lt;h1&gt;It works!&lt;/h1&gt;&quot;);</code></pre>

<h3 id="Custom-content-type">Custom content type</h3>

<pre><code>    $self-&gt;res-&gt;set_content_type(&#39;image/png&#39;);</code></pre>

<h3 id="Return-404-or-500-errors">Return 404 or 500 errors</h3>

<pre><code>    sub some_route {
        my $self = shift;
        if ($missing) {
            return $self-&gt;res-&gt;render_404;
        }
        if ($broken) {
            return $self-&gt;res-&gt;render_500;
        }
    }</code></pre>

<h3 id="Templates">Templates</h3>

<pre><code>    sub hello {
        my ( $self, $name ) = @_;
        $self-&gt;res-&gt;template( &#39;hello.tt&#39;, { name =&gt; $name } );
    }</code></pre>

<p>The above example will render the contents of <code>hello.tt</code>, and it will set the content-type to <code>text/html</code>. To set a different content-type, use <code>set_content_type</code> or any of its aliases:</p>

<pre><code>    sub hello_txt {
        my ( $self, $name ) = @_;
        $self-&gt;res-&gt;text-&gt;template( &#39;hello_txt.tt&#39;, { name =&gt; $name } );
    }</code></pre>

<h3 id="Headers">Headers</h3>

<pre><code>    $self-&gt;set_header( &quot;X-Framework&quot;, &quot;Kelp&quot; )-&gt;render( { success =&gt; \1 } );</code></pre>

<h3 id="Delayed-responses">Delayed responses</h3>

<p>To send a delayed response, have your route return a subroutine.</p>

<pre><code>    sub delayed {
        my $self = shift;
        return sub {
            my $responder = shift;
            $self-&gt;res-&gt;code(200);
            $self-&gt;res-&gt;text-&gt;body(&quot;Better late than never.&quot;);
            $responder-&gt;($self-&gt;res-&gt;finalize);
        };
    }</code></pre>

<p>See the <a>PSGI</a> pod for more information and examples.</p>

<h2 id="Pluggable-modules">Pluggable modules</h2>

<p>Kelp can be extended using custom <i>modules</i>. Each new module must be a subclass of the <code>Kelp::Module</code> namespace. Modules&#39; job is to initialize and register new methods into the web application class. The following is the full code of the <a>Kelp::Module::JSON</a> for example:</p>

<pre><code>    package Kelp::Module::JSON;

    use Kelp::Base &#39;Kelp::Module&#39;;
    use JSON;

    sub build {
        my ( $self, %args ) = @_;
        my $json = JSON-&gt;new;
        $json-&gt;property( $_ =&gt; $args{$_} ) for keys %args;
        $self-&gt;register( json =&gt; $json );
    }

    1;</code></pre>

<p>What is happening here?</p>

<ul>

<li><p>First we create a class <code>Kelp::Module::JSON</code> which inherits <code>Kelp::Module</code>.</p>

</li>
<li><p>Then, we override the <code>build</code> method (of <code>Kelp::Module</code>), create a new JSON object and register it into the web application via the <code>register</code> method.</p>

</li>
</ul>

<p>If we instruct our web application to load the <code>JSON</code> module, it will have a new method <code>json</code> which will be a link to the <code>JSON</code> object initialized in the module.</p>

<p>See more exampled and POD at <a>Kelp::Module</a>.</p>

<h3 id="How-to-load-modules-using-the-config">How to load modules using the config</h3>

<p>There are two modules that are <b>always</b> loaded by each application instance. Those are <code>Config</code> and <code>Routes</code>. The reason behind this is that each and every application always needs a router and configuration. All other modules must be loaded either using the <a href="#load_module">&quot;load_module&quot;</a> method, or using the <code>modules</code> key in the configuration. The default configuration already loads these modules: <code>Template</code>, <code>Logger</code> and <code>JSON</code>. Your configuration can remove some and/or add others. The configuration key <code>modules_init</code> may contain hashes with initialization arguments. See <a>Kelp::Module</a> for configuration examples.</p>

<h1 id="ATTRIBUTES">ATTRIBUTES</h1>

<h2 id="hostname">hostname</h2>

<p>Gets the current hostname.</p>

<pre><code>    sub some_route {
        my $self = shift;
        if ( $self-&gt;hostname eq &#39;prod-host&#39; ) {
            ...
        }
    }</code></pre>

<h2 id="mode">mode</h2>

<p>Sets or gets the current mode. The mode is important for the app to know what configuration file to merge into the main configuration. See <a>Kelp::Module::Config</a> for more information.</p>

<pre><code>    my $app = MyApp-&gt;new( mode =&gt; &#39;development&#39; );
    # conf/config.pl and conf/config_development.pl are merged with priority
    # given to the second one.</code></pre>

<h2 id="path">path</h2>

<p>Gets the current path of the application. That would be the path to <code>app.psgi</code></p>

<h2 id="name">name</h2>

<p>Gets or sets the name of the application. If not set, the name of the main class will be used.</p>

<pre><code>    my $app = MyApp-&gt;new( name =&gt; &#39;Twittar&#39; );</code></pre>

<h2 id="charset">charset</h2>

<p>Sets of gets the encoding charset of the app. It will be <code>UTF-8</code>, if not set to anything else. The charset could also be changed in the config files.</p>

<h2 id="req">req</h2>

<p>This attribute only makes sense if called within a route definition. It will contain a reference to the current <a>Kelp::Request</a> instance.</p>

<pre><code>    sub some_route {
        my $self = shift;
        if ( $self-&gt;req-&gt;is_json ) {
            ...
        }
    }</code></pre>

<h2 id="res">res</h2>

<p>This attribute only makes sense if called within a route definition. It will contain a reference to the current <a>Kelp::Response</a> instance.</p>

<pre><code>    sub some_route {
        my $self = shift;
        $self-&gt;res-&gt;json-&gt;render( { success =&gt; 1 } );
    }</code></pre>

<h1 id="METHODS">METHODS</h1>

<h2 id="build">build</h2>

<p>On it&#39;s own the <code>build</code> method doesn&#39;t do anything. It is called by the constructor, so it can be overridden to add route destinations and initializations.</p>

<pre><code>    package MyApp;

    sub build {
        my $self = shift;
        my $r = $self-&gt;routes;

        # Load some modules
        $self-&gt;load_module(&quot;MongoDB&quot;);
        $self-&gt;load_module(&quot;Validate&quot;);

        # Add all route destinations
        $r-&gt;add(&quot;/one&quot;, &quot;one&quot;);
        ...

    }</code></pre>

<h2 id="load_module">load_module</h2>

<p>Used to load a module. All modules must be under the <code>Kelp::Module::</code> namespace.</p>

<pre><code>    $self-&gt;load_module(&quot;Redis&quot;);
    # Will look for an load Kelp::Module::Redis</code></pre>

<p>See <a>Kelp::Module</a> for more information on making and using modules.</p>

<h2 id="request">request</h2>

<p>This method is used to create the request object for each HTTP request. It returns and instance of <a>Kelp::Request</a>, initialized with the current requests environment. You can override this method to use a custom request module.</p>

<pre><code>    package MyApp;
    use MyApp::Request;

    sub request {
        my ( $self, $env ) = @_;
        return MyApp::Requst-&gt;new( app =&gt; $app, env =&gt; $env );
    }

    # Now each request will be handled by MyApp::Request</code></pre>

<h2 id="before_render">before_render</h2>

<p>Override this method, to modify the response object just before it gets rendered.</p>

<pre><code>    package MyApp;

    sub before_render {
        my $self = shift;
        $self-&gt;res-&gt;set_header(&quot;X-App-Name&quot;, &quot;MyApp&quot;);
    }

    ...</code></pre>

<p>The above is an example of how to insert a custom header into the response of every route.</p>

<h2 id="response">response</h2>

<p>This method creates the response object, e.g. what an HTTP request will return. By default the object created is <a>Kelp::Response</a>. Much like <a href="#request">&quot;request&quot;</a>, the response can also be overridden to use a custom response object.</p>

<h2 id="run">run</h2>

<p>This method builds and returns the PSGI app. You can override it in order to include middleware. See <a href="#Adding-middleware">&quot;Adding middleware&quot;</a> for an example.</p>

<h2 id="param">param</h2>

<p>A shortcut to <code>$self-&gt;req-&gt;param</code>:</p>

<pre><code>    sub some_route {
        my $self = shift;
        if ( $self-&gt;param(&#39;age&#39;) &gt; 18 ) {
            $self-&gt;can_watch_south_path(1);
        }
    }</code></pre>

<p>See <a>Kelp::Request</a> for more information and examples.</p>

<h2 id="stash">stash</h2>

<p>Provides safe access to <code>$self-&gt;req-&gt;stash</code>. When called without arguments, it will return the stash hash. If called with a single argument, it will return the value of the corresponding key in the stash. See <a>&quot;stash&quot; in Kelp::Request</a> for more information and examples.</p>

<h2 id="named">named</h2>

<p>Provides safe access to <code>$self-&gt;req-&gt;named</code>. When called without arguments, it will return the named hash. If called with a single argument, it will return the value of the corresponding key in the named hash. See <a>&quot;named&quot; in Kelp::Request</a> for more information and examples.</p>

<h2 id="url_for">url_for</h2>

<p>A safe shortcut to <code>$self-&gt;routes-&gt;url</code>. Builds a URL from path and arguments.</p>

<pre><code>    sub build {
        my $self = shift;
        $self-&gt;routes-&gt;add(&quot;/:name/:id&quot;, { name =&gt; &#39;name&#39;, to =&gt; sub {
            ...
        }});
    }

    sub check {
        my $self = shift;
        my $url_for_name = $self-&gt;url_for(&#39;name&#39;, name =&gt; &#39;jake&#39;, id =&gt; 1003);
        $self-&gt;res-&gt;redirect_to();
    }</code></pre>


</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#QUICK-START">QUICK START</a></li>
  <li><a href="#KEYWORDS">KEYWORDS</a>
    <ul>
      <li><a href="#app">app</a></li>
      <li><a href="#attr">attr</a></li>
      <li><a href="#route">route</a></li>
      <li><a href="#get-post-put-del">get, post, put, del</a></li>
      <li><a href="#param">param</a></li>
      <li><a href="#stash">stash</a></li>
      <li><a href="#named">named</a></li>
      <li><a href="#req">req</a></li>
      <li><a href="#res">res</a></li>
      <li><a href="#template">template</a></li>
      <li><a href="#run">run</a></li>
    </ul>
  </li>
  <li><a href="#TESTING">TESTING</a></li>
  <li><a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Kelp::Less - Quick prototyping with Kelp</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    use Kelp::Less;

    get &#39;/person/:name&#39; =&gt; sub {
        &quot;Hello &quot; . named &#39;name&#39;;
    };

    run;</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This class exists to provide a way for quick and sloppy prototyping of a web application. It is a wrapper for <a>Kelp</a>, which imports several keywords, making it easier and less verbose to create a quick web app.</p>

<p>It&#39;s called <code>Less</code>, because there is less typing involved, and because it is suited for smaller, less complicated web projects. We encourage you to use it anywhere you see fit, however for mid-size and big applications we recommend that you use the fully structured <a>Kelp</a>. This way you can take advantage of its powerful router, initialization and testing capabilities.</p>

<h1 id="QUICK-START">QUICK START</h1>

<p>Each web app begins with <code>use Kelp::Less;</code>. This automatically imports <code>strict</code>, <code>warnings</code>, <code>v5.10</code> as well as several useful functions. You can pass any parameters to the constructor at the <code>use</code> statement:</p>

<pre><code>    use Kelp::Less mode =&gt; &#39;development&#39;;</code></pre>

<p>The above is equivalent to:</p>

<pre><code>    use Kelp;
    my $app = Kelp-&gt;new( mode =&gt; &#39;development&#39; );</code></pre>

<p>After that, you could add any initializations and attributes. For example, connect to a database or setup cache. <code>Kelp::Less</code> exports <a>attr</a>, so you can use it to register attributes to your app.</p>

<pre><code>    # Connect to DBI and CHI right away
    attr dbh =&gt; sub {
        DBI-&gt;connect( @{ app-&gt;config(&#39;database&#39;) } );
    };

    attr cache =&gt; sub {
        CHI-&gt;new( @{ app-&gt;config(&#39;cache&#39;) } );
    };

    # Another lazy attribute.
    attr version =&gt; sub {
        app-&gt;dbh-&gt;selectrow_array(&quot;SELECT version FROM vars&quot;);
    };

    # Later:
    app-&gt;dbh-&gt;do(...);
    app-&gt;cache-&gt;get(...);
    if ( app-&gt;version ) { ... }</code></pre>

<p>Now is a good time to add routes. Routes are added via the <a href="#route">&quot;route&quot;</a> keyword and they are automatically registered in your app. A route needs two parameters - <code>path</code> and <code>destination</code>. These are exactly equivalent to <a>&quot;add&quot; in Kelp::Routes</a>, and you are encouraged to read its POD to get familiar with how to define routes. Here are a few examples for the impatient:</p>

<pre><code>    # Add a &#39;catch-all-methods&#39; route and send it to an anonymous sub
    route &#39;/hello/:name&#39; =&gt; sub {
        return &quot;Hello &quot; . named(&#39;name&#39;);
    };

    # Add a POST route
    route [ POST =&gt; &#39;/edit/:id&#39; ] =&gt; sub {
        # Do something with named(&#39;id&#39;)
    };

    # Route that runs an existing sub in your code
    route &#39;/login&#39; =&gt; &#39;login&#39;;
    sub login {
        ...
    }</code></pre>

<p>Each route subroutine receives <code>$self</code> and all named placeholders.</p>

<pre><code>    route &#39;/:id/:page&#39; =&gt; sub {
        my ( $self, $id, $page ) = @_;
    };</code></pre>

<p>Here, <code>$self</code> is the app object and it can be used the same way as in a full <a>Kelp</a> route. For the feeling of magic and eeriness, <code>Kelp::Lite</code> aliases <code>app</code> to <code>$self</code>, so the former can be used as a full substitute to the latter. See the exported keywords section for more information.</p>

<p>After you have added all of your routes, it is time to run the app. This is done via a single command:</p>

<pre><code>    run;</code></pre>

<p>It returns PSGI ready subroutine, so you can immediately deploy your new app via Plack:</p>

<pre><code>    &gt; plackup myapp.psgi
    HTTP::Server::PSGI: Accepting connections at http://0:5000/</code></pre>

<h1 id="KEYWORDS">KEYWORDS</h1>

<p>The following list of keywords are exported to allow for less typing in <code>Kelp::Less</code>:</p>

<h2 id="app">app</h2>

<p>This a full alias for <code>$self</code>. It is the application object, and an instance of the <code>Kelp</code> class. You can use it for anything you would use <code>$self</code> inside a route.</p>

<pre><code>    route &#39;/yo&#39; =&gt; sub {
        app-&gt;res-&gt;code(500);
    };</code></pre>

<h2 id="attr">attr</h2>

<p>Assigns lazy or active attributes (using <a>Kelp::Base</a>) to <code>app</code>. Use it to initialize your application.</p>

<pre><code>    attr mongo =&gt; MongoDB::MongoClient-&gt;new( ... );</code></pre>

<h2 id="route">route</h2>

<p>Adds a route to <code>app</code>. It is an alias to <code>$self-&gt;routes-&gt;add</code>, and requires the exact same parameters. See <a>Kelp::Routes</a> for reference.</p>

<pre><code>    route &#39;/get-it&#39; =&gt; sub { &quot;got it&quot; };</code></pre>

<h2 id="get-post-put-del">get, post, put, del</h2>

<p>These are shortcuts to <code>route</code> restricted to the corresponding HTTP method.</p>

<pre><code>    get &#39;/data&#39;  =&gt; sub { &quot;Only works with GET&quot; };
    post &#39;/data&#39; =&gt; sub { &quot;Only works with POST&quot; };
    put &#39;/data&#39;  =&gt; sub { &quot;Only works with PUT&quot; };
    del &#39;/data&#39;  =&gt; sub { &quot;Only works with DELETE&quot; };</code></pre>

<h2 id="param">param</h2>

<p>An alias for <code>$self-&gt;param</code> that gets the GET or POST parameters. When used with no arguments, it will return an array with the names of all http parameters. Otherwise, it will return the value of the requested http parameter.</p>

<pre><code>    get &#39;/names&#39; =&gt; sub {
        my @names = param;
        # Now @names contains the names of the params
    };

    get &#39;/value&#39; =&gt; sub {
        my $id = param &#39;id&#39;;
        # Now $is contains the value of &#39;id&#39;
    };</code></pre>

<h2 id="stash">stash</h2>

<p>An alias for <code>$self-&gt;stash</code>. The stash is a concept originally conceived by the developers of <a>Catalyst</a>. It&#39;s a hash that you can use to pass data from one route to another.</p>

<pre><code>    # Create a bridge route that checks if the user is authenticated, and saves
    # the username in the stash.
    get &#39;/user&#39; =&gt; { bridge =&gt; 1, to =&gt; sub {
        return stash-&gt;{username} = app-&gt;authenticate();
    }};

    # This route is run after the above bridge, so we know that we have an
    # authenticated user and their username in the stash.
    get &#39;/user/welcome&#39; =&gt; sub {
        return &quot;Hello &quot; . stash &#39;username&#39;;
    };</code></pre>

<p>With no arguments <code>stash</code> returns the entire stash hash. A single argument is interpreted as the key to the stash hash and its value is returned accordingly.</p>

<h2 id="named">named</h2>

<p>An alias for <code>$self-&gt;named</code>. The <code>named</code> hash contains the names and values of the named placeholders from the current route&#39;s path. Much like the <code>stash</code>, with no arguments it returns the entire <code>named</code> hash, and with a single argument it returns the value for the corresponding key in the hash.</p>

<pre><code>    get &#39;/:name/:id&#39; =&gt; sub {
        my $name = named &#39;name&#39;;
        my $id = name &#39;id&#39;;
    };</code></pre>

<p>In the above example a GET request to <code>/james/1000</code> will initialize <code>$name</code> with <code>&quot;james&quot;</code> and <code>$id</code> with <code>1000</code>.</p>

<h2 id="req">req</h2>

<p>An alias for <code>$self-&gt;req</code>, this provides quick access to the <a>Kelp::Request</a> object for the current route.</p>

<pre><code>    # Inside a route
    if ( req-&gt;is_ajax ) {
        ...
    }</code></pre>

<h2 id="res">res</h2>

<p>An alias for <code>$self-&gt;res</code>, this is a shortcut for the <a>Kelp::Response</a> object for the current route.</p>

<pre><code>    # Inside a route
    res-&gt;code(403);
    res-&gt;json-&gt;render({ message =&gt; &quot;Forbidden&quot; });</code></pre>

<h2 id="template">template</h2>

<p>A shortcut to <code>$self-&gt;res-&gt;template</code>. Renders a template using the currently loaded template module.</p>

<pre><code>    get &#39;/hello/:name&#39; =&gt; sub {
        template &#39;hello.tt&#39;, { name =&gt; named &#39;name&#39; };
    };</code></pre>

<h2 id="run">run</h2>

<p>Creates and returns a PSGI ready subroutine, and makes the app ready for <code>Plack</code>.</p>

<h1 id="TESTING">TESTING</h1>

<p>When writing a <code>Kelp::Less</code> app, we don&#39;t have a separate class to initialize as we please and feed into a <a>Kelp::Test</a> object. In this case, the <code>Kelp::Test</code> object can be initialized with the name of the <code>PSGI</code> file in the <code>psgi</code> argument.</p>

<pre><code>    # t/main.t
    use Kelp::Test;

    my $t = Kelp::Test-&gt;new( psgi =&gt; &#39;app.psgi&#39; );
    # Do some tests ...</code></pre>

<p>Since you don&#39;t have control over the creation of the <code>Kelp</code> object, if you need to specify a different mode for testing, you can use the <code>PLACK_ENV</code> environmental variable:</p>

<pre><code>    &gt; PLACK_ENV=test prove -l</code></pre>

<p>This will enable the <code>conf/config_test.pl</code> configuration, which you should tailor to your testing needs.</p>

<h1 id="ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</h1>

<p>This module&#39;s interface was inspired by <a>Dancer</a>, which in its turn was inspired by Sinatra, so Viva La Open Source!</p>


</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#ATTRIBUTES">ATTRIBUTES</a>
    <ul>
      <li><a href="#render">render</a></li>
      <li><a href="#set_content_type">set_content_type</a></li>
      <li><a href="#text-html-json-xml">text, html, json, xml</a></li>
      <li><a href="#set_header">set_header</a></li>
      <li><a href="#no_cache">no_cache</a></li>
      <li><a href="#set_code">set_code</a></li>
      <li><a href="#render_404">render_404</a></li>
      <li><a href="#render_500">render_500</a></li>
      <li><a href="#template">template</a></li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Kelp::Response - Format an HTTP response</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p>Examples of route definitions make a lot more sense when showing how to use this module. Note that in the below examples <code>$self-&gt;res</code> is an instance of <code>Kelp::Response</code>:</p>

<pre><code>    # Render simple text
    sub text {
        my $self = shift;
        $self-&gt;res-&gt;text-&gt;render(&quot;It works!&quot;);
    }

    # Render advanced HTML
    sub html {
        my $self = shift;
        $self-&gt;res-&gt;html-&gt;render(&quot;&lt;h1&gt;It works!&lt;/h1&gt;&quot;);
    }

    # Render a mysterious JSON structure
    sub json {
        my $self = shift;
        $self-&gt;res-&gt;json-&gt;render({ why =&gt; &#39;no&#39; });
    }

    # Render the stock 404
    sub missing {
        my $self = shift;
        $self-&gt;res-&gt;render_404;
    }

    # Render a template
    sub view {
        my $self = shift;
        $self-&gt;res-&gt;template(&#39;view.tt&#39;, { name =&gt; &#39;Rick James&#39; } );
    }</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>The <a>PSGI</a> specification requires that each route returns an array with status code, headers and body. <code>Plack::Response</code> already provides many useful methods that deal with that. This module extends <code>Plack::Response</code> to add the tools we need to write graceful PSGI compliant responses. Some methods return <code>$self</code>, which makes them easy to chain.</p>

<h1 id="ATTRIBUTES">ATTRIBUTES</h1>

<h2 id="render">render</h2>

<p>This method tries to act smart, without being a control freak. It will fill out the blanks, unless they were previously filled out by someone else. Here is what is does:</p>

<ul>

<li><p>If the response code was not previously set, this method will set it to 200.</p>

</li>
<li><p>If no content-type is previously set, <code>render</code> will set is based on the type of the data rendered. If it&#39;s a reference, then the content-type will be set to <code>application/json</code>, otherwise it will be set to <code>text/html</code>.</p>

<pre><code>    # Will set the content-type to json
    $res-&gt;render( { numbers =&gt; [ 1, 2, 3 ] } );</code></pre>

</li>
<li><p>Last, the data will be encoded with the charset specified by the app.</p>

</li>
</ul>

<h2 id="set_content_type">set_content_type</h2>

<p>Sets the content type of the response and returns <code>$self</code>.</p>

<pre><code>    # Inside a route definition
    $self-&gt;res-&gt;set_content_type(&#39;image/png&#39;);</code></pre>

<h2 id="text-html-json-xml">text, html, json, xml</h2>

<p>These methods are shortcuts for <code>set_content_type</code> with the corresponding type. All of them set the content-type header and return <code>$self</code> so they can be chained.</p>

<pre><code>    $self-&gt;res-&gt;text-&gt;render(&quot;word&quot;);
    $self-&gt;res-&gt;html-&gt;render(&quot;&lt;p&gt;word&lt;/p&gt;&quot;);
    $self-&gt;res-&gt;json-&gt;render({ word =&gt; \1 });</code></pre>

<h2 id="set_header">set_header</h2>

<p>Sets response headers. This is a wrapper around <a>&quot;header&quot; in Plack::Response</a>, which returns <code>$self</code> to allow for chaining.</p>

<pre><code>    $self-&gt;res-&gt;set_header(&#39;X-Something&#39; =&gt; &#39;Value&#39;)-&gt;text-&gt;render(&quot;Hello&quot;);</code></pre>

<h2 id="no_cache">no_cache</h2>

<p>A convenience method that sets several response headers instructing most browsers to not cache the response.</p>

<pre><code>    $self-&gt;res-&gt;no_cache-&gt;json-&gt;render({ epoch =&gt; time });</code></pre>

<p>The above response will contain headers that disable caching.</p>

<h2 id="set_code">set_code</h2>

<p>Set the response code.</p>

<pre><code>    $self-&gt;res-&gt;set_code(401)-&gt;render(&quot;Access denied&quot;);</code></pre>

<h2 id="render_404">render_404</h2>

<p>A convenience method that sets code 404 and returns &quot;File Not Found&quot;.</p>

<pre><code>    sub some_route {
        if ( not $self-&gt;req-&gt;param(&#39;ok&#39;) ) {
            return $self-&gt;res-&gt;render_404;
        }
    }</code></pre>

<p>If your application&#39;s tone is overly friendly or humorous, you will want to create a custom 404 page. The best way to do this is to subclass this module into your own class, for example <code>MyApp::Response</code>. Then override the <code>render_404</code> method.</p>

<pre><code>    package MyApp::Response;
    use parent &#39;Kelp::Response&#39;;

    sub render_404 {
        my $self = shift;
        $self-&gt;set_code(404)-&gt;template(&#39;errors/404.tt&#39;);
    }</code></pre>

<p>You&#39;ll have to override the <a>&quot;response&quot; in Kelp</a> method in your main module too, in order to instruct it to use your new class:</p>

<pre><code>    package MyApp;
    use parent &#39;Kelp&#39;;

    sub response {
        my $self = shift;
        return MyApp::Response-&gt;new( app =&gt; $self );
    }</code></pre>

<h2 id="render_500">render_500</h2>

<p>Renders the stock &quot;500 - Server Error&quot; message. See <a href="#render_404">&quot;render_404&quot;</a> for examples on how to customize it.</p>

<h2 id="template">template</h2>

<p>This method renders a template. The template should be previously configured by you and included via a module. See <a>Kelp::Module::Template</a> for a template module.</p>

<pre><code>    sub some_route {
        my $self = shift;
        $self-&gt;res-&gt;template(&#39;home.tt&#39;, { login =&gt; &#39;user&#39; });
    }</code></pre>


</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">




</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">




</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#REGISTERED-METHODS">REGISTERED METHODS</a>
    <ul>
      <li><a href="#config">config</a></li>
      <li><a href="#config_hash">config_hash</a></li>
    </ul>
  </li>
  <li><a href="#DEFAULTS">DEFAULTS</a>
    <ul>
      <li><a href="#charset">charset</a></li>
      <li><a href="#app_url">app_url</a></li>
      <li><a href="#modules">modules</a></li>
      <li><a href="#modules_init">modules_init</a></li>
      <li><a href="#middleware">middleware</a></li>
      <li><a href="#middleware_init">middleware_init</a></li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Kelp::Module::Config - Configuration for Kelp applications</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This is one of the two modules that are automatically loaded for each and every Kelp application. It uses <a>Config::Hash</a> to read Perl-style hashes from files and merge them depending on the value of the <code>mode</code> attribute.</p>

<p>The main configuration file name is <code>config.pl</code>, and it will be searched in the <code>conf</code> directory or <code>../conf</code>. The latter is convenient for running tests which use the same configuration settings as the main app.</p>

<h1 id="REGISTERED-METHODS">REGISTERED METHODS</h1>

<p>This module registers the following methods into the underlying app:</p>

<h2 id="config">config</h2>

<p>A wrapper for the <code>get</code> method in <a>Config::Hash</a>.</p>

<pre><code>    # Somewhere in the app
    my $pos = $self-&gt;config(&#39;row.col.position&#39;);

    # Gets {row}-&gt;{col}-&gt;{position} from the config hash</code></pre>

<h2 id="config_hash">config_hash</h2>

<p>A reference to the entire configuration hash.</p>

<pre><code>    my $pos = $self-&gt;config_hash-&gt;{row}-&gt;{col}-&gt;{position};</code></pre>

<p>Using this or <code>config</code> is entirely up to the application developer.</p>

<h1 id="DEFAULTS">DEFAULTS</h1>

<p>This module sets certain default values. All of them may be overridden in any of the <code>conf/</code> files. It probably pays to view the code of this module and look and the <code>defaults</code> sub to see what is being set by default, but here is the short version:</p>

<h2 id="charset">charset</h2>

<p><code>UTF-8</code></p>

<h2 id="app_url">app_url</h2>

<p><code>http://localhost:5000</code></p>

<h2 id="modules">modules</h2>

<p>An arrayrf with module names to load on startup. The default value is <code>[&#39;JSON&#39;, &#39;Template&#39;, &#39;Logger&#39;]</code></p>

<h2 id="modules_init">modules_init</h2>

<p>A hashref with initializations for each of the loaded modules, except this one, ironically.</p>

<h2 id="middleware">middleware</h2>

<p>An arrayref with middleware to load on startup. The default value is an empty array.</p>

<h2 id="middleware_init">middleware_init</h2>

<p>A hashref with iitialization arguments for each of the loaded middleware.</p>


</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#REGISTERED-METHODS">REGISTERED METHODS</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Kelp::Module::JSON - Simple JSON module for a Kelp application</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    package MyApp;
    use Kelp::Base &#39;Kelp&#39;;

    sub some_route {
        my $self = shift;
        return $self-&gt;json-&gt;encode( { yes =&gt; 1 } );
    }</code></pre>

<h1 id="REGISTERED-METHODS">REGISTERED METHODS</h1>

<p>This module registers only one method into the application: <code>json</code>.</p>


</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">




</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">




</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#ATTRIBUTES">ATTRIBUTES</a>
    <ul>
      <li><a href="#app">app</a></li>
      <li><a href="#psgi">psgi</a></li>
      <li><a href="#res">res</a></li>
    </ul>
  </li>
  <li><a href="#METHODS">METHODS</a>
    <ul>
      <li><a href="#request">request</a></li>
      <li><a href="#code_is-code_isnt">code_is, code_isnt</a></li>
      <li><a href="#content_is-content_isnt">content_is, content_isnt</a></li>
      <li><a href="#content_like-content_unlike">content_like, content_unlike</a></li>
      <li><a href="#content_type_is-content_type_isnt">content_type_is, content_type_isnt</a></li>
      <li><a href="#header_is-header_isnt">header_is, header_isnt</a></li>
      <li><a href="#header_like-header_unlike">header_like, header_unlike</a></li>
      <li><a href="#json_cmp">json_cmp</a></li>
      <li><a href="#note">note</a></li>
      <li><a href="#diag_headers">diag_headers</a></li>
      <li><a href="#diag_content">diag_content</a></li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Kelp::Test - Automated tests for a Kelp web app</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    use MyApp;
    use Kelp::Test;
    use HTTP::Request::Common;

    my $app = MyApp-&gt;new;
    my $t = Kelp::Test-&gt;new( app =&gt; $app );

    $t-&gt;request( GET &#39;/path&#39; )
      -&gt;code_is(200)
      -&gt;content_is(&quot;It works&quot;);

    $t-&gt;request( POST &#39;/api&#39; )
      -&gt;json_cmp({auth =&gt; 1});</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module provides basic tools for testing a Kelp based web application. It is object oriented, and all methods return <code>$self</code>, so they can be chained together. Testing is done by sending HTTP requests to an already built application and analyzing the response. Therefore, each test usually begins with the <a href="#request">&quot;request&quot;</a> method, which takes a single <a>HTTP::Request</a> parameter. It sends the request to the web app and saves the response as an <a>HTTP::Response</a> object.</p>

<h1 id="ATTRIBUTES">ATTRIBUTES</h1>

<h2 id="app">app</h2>

<p>The Kelp::Test object is instantiated with single attribute called <code>app</code>. It is a reference to a Kelp based web app.</p>

<pre><code>    my $myapp = MyApp-&gt;new;
    my $t = Kelp::Test-&gt;new( app =&gt; $myapp );</code></pre>

<p>From this point on, all requests run with <code>$t-&gt;request</code> will be sent to <code>$app</code>.</p>

<h2 id="psgi">psgi</h2>

<p>This is only used when testing <a>Kelp::Less</a> apps. Since we don&#39;t have an application class to load, we need to load the <code>app.psgi</code> file.</p>

<pre><code>    my $t = Kelp::Test-&gt;new( psgi =&gt; &#39;app.psgi&#39; );</code></pre>

<p>All testing methods work exactly the same way. Note that since we don&#39;t have control over how the <code>Kelp</code> class is loaded, we may have to use the <code>PLACK_ENV</code> environment variable to set different testing modes.</p>

<pre><code>    &gt; PLACK_ENV=test prove -l</code></pre>

<p>The above is the same as:</p>

<pre><code>    use Kelp::Less mode =&gt; &#39;test&#39;;</code></pre>

<h2 id="res">res</h2>

<p>Each time <code>$t-</code>request&gt; is used to send a request, an HTTP::Response object is returned and saved in the <code>res</code> attribute. You can use it to run tests, although as you will see, this module provides methods which make this a lot easier. It is recommended that you use the convenience methods rather than using <code>res</code>.</p>

<pre><code>    $t-&gt;request( GET &#39;/path&#39; )
    is $t-&gt;res-&gt;code, 200, &quot;It&#39;s a success&quot;;</code></pre>

<h1 id="METHODS">METHODS</h1>

<h2 id="request">request</h2>

<p><code>request( $http_request )</code></p>

<p>Takes an <a>HTTP::Request</a> object and sends it to the application. When the <a>HTTP::Response</a> object is returned, it is initialized in the <a href="#res">&quot;res&quot;</a> attribute. It is very convenient to use <a>HTTP::Request::Common</a> in your test modules, so you can take advantage of the simplified syntax for creating an HTTP request.</p>

<pre><code>    $t-&gt;request( POST &#39;/api&#39;, [ user =&gt; &#39;jane&#39; ] );</code></pre>

<p>This method returns <code>$self</code>, so other methods can be chained after it.</p>

<h2 id="code_is-code_isnt">code_is, code_isnt</h2>

<p><code>code_is( $code, $test_name )</code>, <code>code_isnt( $code, $test_name )</code></p>

<p>Tests if the last response returned a status code equal or not equal to <code>$code</code>. An optional name of the test can be added as a second parameter.</p>

<pre><code>    $t-&gt;request( GET &#39;/path&#39; )-&gt;code_is(200);
    $t-&gt;request( GET &#39;/path&#39; )-&gt;code_isnt(500);</code></pre>

<h2 id="content_is-content_isnt">content_is, content_isnt</h2>

<p><code>content_is( $value, $test_name )</code>, <code>content_isnt( $value, $test_name )</code></p>

<p>Tests if the last response returned content equal or not equal to <code>$value</code>. An optional name of the test can be added as a second parameter.</p>

<pre><code>    $t-&gt;request( GET &#39;/path&#39; )-&gt;content_is(&quot;Ok.&quot;);
    $t-&gt;request( GET &#39;/path&#39; )-&gt;content_isnt(&quot;Fail.&quot;);</code></pre>

<h2 id="content_like-content_unlike">content_like, content_unlike</h2>

<p><code>content_like( $regexp, $test_name )</code>, <code>content_unlike( $regexp, $test_name )</code></p>

<p>Tests if the last response returned content that matches or doesn&#39;t match <code>$regexp</code>. An optional name of the test can be added as a second parameter.</p>

<pre><code>    $t-&gt;request( GET &#39;/path&#39; )-&gt;content_like(qr{Amsterdam});
    $t-&gt;request( GET &#39;/path&#39; )-&gt;content_unlike(qr{Rotterdam});</code></pre>

<h2 id="content_type_is-content_type_isnt">content_type_is, content_type_isnt</h2>

<p><code>content_type_is( $value, $test_name )</code>, <code>content_type_isnt( $value, $test_name )</code></p>

<p>Tests if the last response&#39;s content-type header is equal or not equal to <code>$value</code>. An optional name of the test can be added as a second parameter.</p>

<pre><code>    $t-&gt;request( GET &#39;/path&#39; )-&gt;content_type_is(&quot;text/plain&quot;);
    $t-&gt;request( GET &#39;/path&#39; )-&gt;content_type_isnt(&quot;text/html&quot;);</code></pre>

<h2 id="header_is-header_isnt">header_is, header_isnt</h2>

<p><code>header_is( $header, $value, $test_name )</code>, <code>header_isnt( $header, $value, $test_name )</code></p>

<p>Tests if the last response returned a header <code>$header</code> that is equal or not equal to <code>$value</code>. An optional name of the test can be added as a second parameter.</p>

<pre><code>    $t-&gt;request( GET &#39;/path&#39; )-&gt;header_is( &quot;Pragma&quot;, &quot;no-cache&quot; );
    $t-&gt;request( GET &#39;/path&#39; )-&gt;header_isnt( &quot;X-Check&quot;, &quot;yes&quot; );</code></pre>

<h2 id="header_like-header_unlike">header_like, header_unlike</h2>

<p><code>header_like( $header, $regexp, $test_name )</code>, <code>header_unlike( $header, $regexp, $test_name )</code></p>

<p>Tests if the last response returned a header <code>$header</code> that matches or doesn&#39;t match <code>$regexp</code>. An optional name of the test can be added as a second parameter.</p>

<pre><code>    $t-&gt;request( GET &#39;/path&#39; )-&gt;header_like( &quot;Content-Type&quot;, qr/json/ );
    $t-&gt;request( GET &#39;/path&#39; )-&gt;header_unlike( &quot;Content-Type&quot;, qr/image/ );</code></pre>

<h2 id="json_cmp">json_cmp</h2>

<p><code>json_cmp( $expected, $test_name )</code></p>

<p>This tests for two things: If the returned <code>content-type</code> is <code>application-json</code>, and if the returned JSON structure matches the structure specified in <code>$expected</code>. To compare the two structures this method uses <code>cmp_deeply</code> from <a>Test::Deep</a>, so you can use all the goodies from the <code>SPECIAL-COMPARISONS-PROVIDED</code> section of the Test::Deep module.</p>

<pre><code>    $t-&gt;request( GET &#39;/api&#39; )-&gt;json_cmp(
        {
            auth      =&gt; 1,
            timestamp =&gt; ignore(),
            info      =&gt; subhashof( { name =&gt; &#39;Rick James&#39; } )
        }
    );</code></pre>

<p>An optional name of the test can be added as a second parameter.</p>

<h2 id="note">note</h2>

<p><code>note( $note )</code></p>

<p>Print a note, using the <a>Test::More</a> <code>note</code> function.</p>

<pre><code>    $t-&gt;request( GET &#39;/path&#39; )
      -&gt;note(&quot;Checking headers now&quot;)
      -&gt;header_is( &quot;Content-Type&quot;, qr/json/ );</code></pre>

<h2 id="diag_headers">diag_headers</h2>

<p>Prints all headers for debugging purposes.</p>

<pre><code>    $t-&gt;request( GET &#39;/path&#39; )
      -&gt;header_is( &quot;Content-Type&quot;, qr/json/ )
      -&gt;diag_headers();</code></pre>

<h2 id="diag_content">diag_content</h2>

<p>Prints the entire content for debugging purposes.</p>

<pre><code>    $t-&gt;request( GET &#39;/path&#39; )
      -&gt;content_is(&quot;Well&quot;)
      -&gt;diag_content();</code></pre>


</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#ATTRIBUTES">ATTRIBUTES</a>
    <ul>
      <li><a href="#app">app</a></li>
      <li><a href="#stash">stash</a></li>
      <li><a href="#named">named</a></li>
      <li><a href="#param">param</a></li>
      <li><a href="#is_ajax">is_ajax</a></li>
      <li><a href="#is_json">is_json</a></li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Kelp::Request - Request class for a Kelp application</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    my $request = Kelp::Request( app =&gt; $app, env =&gt; $env );</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module provides a convenience layer on top of <a>Plack::Request</a>. It extends it to add several convenience methods.</p>

<h1 id="ATTRIBUTES">ATTRIBUTES</h1>

<h2 id="app">app</h2>

<p>A reference to the Kelp application.</p>

<h2 id="stash">stash</h2>

<p>An all use, utility hash to use to pass information between routes.</p>

<h2 id="named">named</h2>

<p>This hash is initialized with the named placeholders of the path that the current route is processing.</p>

<h2 id="param">param</h2>

<p>Returns the HTTP parameters of the request. This method delegates all the work to <a>&quot;param&quot; in Plack::Request</a>, except when the content type of the request is <code>application/json</code>. In that case, it will decode the JSON body and return as follows:</p>

<ul>

<li><p>If no arguments are passed, then it will return the names of the HTTP parameters when called in array contest, and a reference to the entire JSON hash when called in scalar context.</p>

<pre><code>    # JSON body = { bar =&gt; 1, foo =&gt; 2 }
    my @names = $self-&gt;param;   # @names = (&#39;bar&#39;, &#39;foo&#39;)
    my $json = $self-&gt;param;    # $json = { bar =&gt; 1, foo =&gt; 2 }</code></pre>

</li>
<li><p>If a single argument is passed, then the corresponding value in the JSON document is returned.</p>

<pre><code>    my $bar = $self-&gt;param(&#39;bar&#39;);  # $bar = 1</code></pre>

</li>
</ul>

<h2 id="is_ajax">is_ajax</h2>

<p>Returns true if the request was called with <code>XMLHttpRequest</code>.</p>

<h2 id="is_json">is_json</h2>

<p>Returns true if the request&#39;s content type was <code>application/json</code>.</p>


</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#PLACEHOLDERS">PLACEHOLDERS</a>
    <ul>
      <li><a href="#Explicit">Explicit</a></li>
      <li><a href="#Optional">Optional</a></li>
      <li><a href="#Wildcards">Wildcards</a></li>
      <li><a href="#Using-curly-braces">Using curly braces</a></li>
    </ul>
  </li>
  <li><a href="#BRIDGES">BRIDGES</a></li>
  <li><a href="#TREES">TREES</a></li>
  <li><a href="#ATTRIBUTES">ATTRIBUTES</a>
    <ul>
      <li><a href="#base">base</a></li>
    </ul>
  </li>
  <li><a href="#SUBROUTINES">SUBROUTINES</a>
    <ul>
      <li><a href="#add">add</a>
        <ul>
          <li><a href="#Destination-Options">Destination Options</a>
            <ul>
              <li><a href="#to">to</a></li>
              <li><a href="#via">via</a></li>
              <li><a href="#name">name</a></li>
              <li><a href="#check">check</a></li>
              <li><a href="#defaults">defaults</a></li>
              <li><a href="#bridge">bridge</a></li>
              <li><a href="#tree">tree</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#match">match</a></li>
    </ul>
  </li>
  <li><a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Kelp::Routes - Routing for a Kelp app</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    use Kelp::Routes;
    my $r = Kelp::Routes-&gt;new( base =&gt; &#39;MyApp&#39; );
    $r-&gt;add( &#39;/home&#39;, &#39;home&#39; );</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>The router provides the connection between the HTTP requests and the web application code. It tells the application <i>&quot;If you see a request coming to *this* URI, send it to *that* subroutine for processing&quot;</i>. For example, if a request comes to <code>/home</code>, then send it to <code>sub home</code> in the current namespace. The process of capturing URIs and sending them to their corresponding code is called routing.</p>

<p>This router was specifically crafted as part of the <code>Kelp</code> web framework. It is, however, possible to use it on its own, if needed.</p>

<p>It provides a simple, yet sophisticated routing utilizing Perl 5.10&#39;s regular expressions, which makes it fast, robust and reliable.</p>

<p>The routing process can roughly be broken down into three steps:</p>

<dl>

<dt id="Adding-routes"><b>Adding routes</b></dt>
<dd>

<p>First you create a router object:</p>

<pre><code>    my $r = Kelp::Routes-&gt;new();</code></pre>

<p>Then you add your application&#39;s routes and their descriptions:</p>

<pre><code>    $r-&gt;add( &#39;/path&#39; =&gt; &#39;Module::function&#39; );
    ...</code></pre>

</dd>
<dt id="Matching"><b>Matching</b></dt>
<dd>

<p>Once you have your routes added, you can match with the <a href="#match">&quot;match&quot;</a> subroutine.</p>

<pre><code>    $r-&gt;match( $path, $method );</code></pre>

<p>The Kelp framework already does matching for you, so you may never have to do your own matching. The above example is provided only for reference.</p>

</dd>
<dt id="Building-URLs-from-routes"><b>Building URLs from routes</b></dt>
<dd>

<p>You can name each of your routes, and use that name later to build a URL:</p>

<pre><code>    $r-&gt;add( &#39;/begin&#39; =&gt; { to =&gt; &#39;function&#39;, name =&gt; &#39;home&#39; } );
    my $url = $r-&gt;url(&#39;home&#39;);    # /begin</code></pre>

<p>This can be used in views and other places where you need the full URL of a route.</p>

</dd>
</dl>

<h1 id="PLACEHOLDERS">PLACEHOLDERS</h1>

<p>Often routes may get more complicated. They may contain variable parts. For example this one <code>/user/1000</code> is expected to do something with user ID 1000. So, in this case we need to capture a route that begins with <code>/user/</code> and then has something else after it.</p>

<p>Naturally, when it comes to capturing routes, the first instinct of the Perl programmer is to use regular expressions, like this:</p>

<pre><code>    qr{/user/(\d+)} -&gt; &quot;sub home&quot;</code></pre>

<p>This module will let you do that, however regular expressions can get very complicated, and it won&#39;t be long before you lose track of what does what.</p>

<p>This is why a good router (this one included) allows for <i>named placeholders</i>. These are words prefixed with special symbols, which denote a variable piece in the URI. To use the above example:</p>

<pre><code>    &quot;/user/:id&quot; -&gt; &quot;sub home&quot;</code></pre>

<p>It looks a little cleaner.</p>

<p>Placeholders are variables you place in the route path. They are identified by a prefix character and their names must abide to the rules of a regular Perl variable. If necessary, curly braces can be used to separate placeholders from the rest of the path.</p>

<p>There are three types of place holders:</p>

<h2 id="Explicit">Explicit</h2>

<p>These placeholders begin with a column (<code>:</code>) and must have a value in order for the route to match. All characters are matched, except for the forward slash.</p>

<pre><code>    $r-&gt;add( &#39;/user/:id&#39; =&gt; &#39;module#sub&#39; );
    # /user/a       -&gt; match (id = &#39;a&#39;)
    # /user/123     -&gt; match (id = 123)
    # /user/        -&gt; no match
    # /user         -&gt; no match
    # /user/10/foo  -&gt; no match

    $r-&gt;add( &#39;/page/:page/line/:line&#39; =&gt; &#39;module#sub&#39; );
    # /page/1/line/2        -&gt; match (page = 1, line = 2)
    # /page/bar/line/foo    -&gt; match (page = &#39;bar&#39;, line = &#39;foo&#39;)
    # /page/line/4          -&gt; no match
    # /page/5               -&gt; no match

    $r-&gt;add( &#39;/{:a}ing/{:b}ing&#39; =&gt; &#39;module#sub&#39; );
    # /walking/singing      -&gt; match (a = &#39;walk&#39;, b = &#39;sing&#39;)
    # /cooking/ing          -&gt; no match
    # /ing/ing              -&gt; no match</code></pre>

<h2 id="Optional">Optional</h2>

<p>Optional placeholders begin with a question mark <code>?</code> and denote an optional value. You may also specify a default value for the optional placeholder via the <a href="#defaults">&quot;defaults&quot;</a> option. Again, like the explicit placeholders, the optional ones capture all characters, except the forward slash.</p>

<pre><code>    $r-&gt;add( &#39;/data/?id&#39; =&gt; &#39;module#sub&#39; );
    # /bar/foo          -&gt; match ( id = &#39;foo&#39; )
    # /bar/             -&gt; match ( id = undef )
    # /bar              -&gt; match ( id = undef )

    $r-&gt;add( &#39;/:a/?b/:c&#39; =&gt; &#39;module#sub&#39; );
    # /bar/foo/baz      -&gt; match ( a = &#39;bar&#39;, b = &#39;foo&#39;, c = &#39;baz&#39; )
    # /bar/foo          -&gt; match ( a = &#39;bar&#39;, b = undef, c = &#39;foo&#39; )
    # /bar              -&gt; no match
    # /bar/foo/baz/moo  -&gt; no match</code></pre>

<p>Optional default values may be specified via the <code>defaults</code> option.</p>

<pre><code>    $r-&gt;add(
        &#39;/user/?name&#39; =&gt; {
            to       =&gt; &#39;module#sub&#39;,
            defaults =&gt; { name =&gt; &#39;hank&#39; }
        }
    );

    # /user             -&gt; match ( name = &#39;hank&#39; )
    # /user/            -&gt; match ( name = &#39;hank&#39; )
    # /user/jane        -&gt; match ( name = &#39;jane&#39; )
    # /user/jane/cho    -&gt; no match</code></pre>

<h2 id="Wildcards">Wildcards</h2>

<p>The wildcard placeholders expect a value and capture all characters, including the forward slash.</p>

<pre><code>    $r-&gt;add( &#39;/:a/*b/:c&#39;  =&gt; &#39;module#sub&#39; );
    # /bar/foo/baz/bat  -&gt; match ( a = &#39;bar&#39;, b = &#39;foo/baz&#39;, c = &#39;bat&#39; )
    # /bar/bat          -&gt; no match</code></pre>

<h2 id="Using-curly-braces">Using curly braces</h2>

<p>Curly braces may be used to separate the placeholders from the rest of the path:</p>

<pre><code>    $r-&gt;add( &#39;/{:a}ing/{:b}ing&#39; =&gt; &#39;module#sub&#39; );
    # /looking/seeing       -&gt; match ( a = &#39;look&#39;, b = &#39;see&#39; )
    # /ing/ing              -&gt; no match

    $r-&gt;add( &#39;/:a/{?b}ing&#39; =&gt; &#39;module#sub&#39; );
    # /bar/hopping          -&gt; match ( a = &#39;bar&#39;, b = &#39;hopp&#39; )
    # /bar/ing              -&gt; match ( a = &#39;bar&#39; )
    # /bar                  -&gt; no match

    $r-&gt;add( &#39;/:a/{*b}ing/:c&#39; =&gt; &#39;module#sub&#39; );
    # /bar/hop/ping/foo     -&gt; match ( a = &#39;bar&#39;, b = &#39;hop/p&#39;, c = &#39;foo&#39; )
    # /bar/ing/foo          -&gt; no match</code></pre>

<h1 id="BRIDGES">BRIDGES</h1>

<p>The <a href="#match">&quot;match&quot;</a> subroutine will stop and return the route that best matches the specified path. If that route is marked as a bridge, then <a href="#match">&quot;match&quot;</a> will continue looking for another match, and will eventually return an array of one or more routes. Bridges can be used for authentication or other route preprocessing.</p>

<pre><code>    $r-&gt;add( &#39;/users&#39;, { to =&gt; &#39;Users::auth&#39;, bridge =&gt; 1 } );
    $r-&gt;add( &#39;/users/:action&#39; =&gt; &#39;Users::dispatch&#39; );</code></pre>

<p>The above example will require <i>/users/profile</i> to go through two subroutines: <code>Users::auth</code> and <code>Users::dispatch</code>:</p>

<pre><code>    my $arr = $r-&gt;match(&#39;/users/view&#39;);
    # $arr is an array of two routes now, the bridge and the last one matched</code></pre>

<h1 id="TREES">TREES</h1>

<p>A quick way to add bridges is to use the <a href="#tree">&quot;tree&quot;</a> option. It allows you to define all routes under a bridge. Example:</p>

<pre><code>    $r-&gt;add(
        &#39;/users&#39; =&gt; {
            to   =&gt; &#39;users#auth&#39;,
            name =&gt; &#39;users&#39;,
            tree =&gt; [
                &#39;/profile&#39; =&gt; {
                    name =&gt; &#39;profile&#39;,
                    to   =&gt; &#39;users#profile&#39;
                },
                &#39;/settings&#39; =&gt; {
                    name =&gt; &#39;settings&#39;,
                    to   =&gt; &#39;users#settings&#39;,
                    tree =&gt; [
                        &#39;/email&#39; =&gt; { name =&gt; &#39;email&#39;, to =&gt; &#39;users#email&#39; },
                        &#39;/login&#39; =&gt; { name =&gt; &#39;login&#39;, to =&gt; &#39;users#login&#39; }
                    ]
                }
            ]
        }
    );</code></pre>

<p>The above call to <code>add</code> causes the following to occur under the hood:</p>

<ul>

<li><p>The paths of all routes inside the tree are joined to the path of their parent, so the following five new routes are created:</p>

<pre><code>    /users                  -&gt; MyApp::Users::auth
    /users/profile          -&gt; MyApp::Users::profile
    /users/settings         -&gt; MyApp::Users::settings
    /users/settings/email   -&gt; MyApp::Users::email
    /users/settings/login   -&gt; MyApp::Users::login</code></pre>

</li>
<li><p>The names of the routes are joined via <code>_</code> with the name of their parent:</p>

<pre><code>    /users                  -&gt; &#39;users&#39;
    /users/profile          -&gt; &#39;users_profile&#39;
    /users/settings         -&gt; &#39;users_settings&#39;
    /users/settings/email   -&gt; &#39;users_settings_email&#39;
    /users/settings/login   -&gt; &#39;users_settings_login&#39;</code></pre>

</li>
<li><p>The <code>/users</code> and <code>/users/settings</code> routes are automatically marked as bridges, because they contain a tree.</p>

</li>
</ul>

<h1 id="ATTRIBUTES">ATTRIBUTES</h1>

<h2 id="base">base</h2>

<p>Sets the base class for the routes destinations.</p>

<pre><code>    my $r = Kelp::Routes-&gt;new( base =&gt; &#39;MyApp&#39; );</code></pre>

<p>This will prepend <code>MyApp::</code> to all route destinations.</p>

<pre><code>    $r-&gt;add( &#39;/home&#39; =&gt; &#39;home&#39; );          # /home -&gt; MyApp::home
    $r-&gt;add( &#39;/user&#39; =&gt; &#39;user#home&#39; );     # /user -&gt; MyApp::User::home
    $r-&gt;add( &#39;/view&#39; =&gt; &#39;User::view&#39; );    # /view -&gt; MyApp::User::view</code></pre>

<p>A Kelp application will automatically set this value to the name of the main class. If you need to use a route located in another package, you&#39;ll have to wrap it in a local sub:</p>

<pre><code>    # Problem:

    $r-&gt;add( &#39;/outside&#39; =&gt; &#39;Outside::Module::route&#39; );
    # /outside -&gt; MyApp::Outside::Module::route
    # (most likely not what you want)

    # Solution:

    $r-&gt;add( &#39;/outside&#39; =&gt; &#39;outside&#39; );
    ...
    sub outside {
        return Outside::Module::route;
    }</code></pre>

<h1 id="SUBROUTINES">SUBROUTINES</h1>

<h2 id="add">add</h2>

<p>Adds a new route definition to the routes array.</p>

<pre><code>    $r-&gt;add( $path, $destination );</code></pre>

<p><code>$path</code> can be a path string, e.g. <code>&#39;/user/view&#39;</code> or an ARRAY containing a method and a path, e.g. <code>[ PUT =&gt; &#39;/item&#39; ]</code>.</p>

<p>The route destination is very flexible. It can be one of these three things:</p>

<ul>

<li><p>A string name of a subroutine, for example <code>&quot;Users::item&quot;</code>. Using a <code>#</code> sign to replace <code>::</code> is also allowed, in which case the name will get converted. <code>&quot;users#item&quot;</code> becomes <code>&quot;Users::item&quot;</code>.</p>

<pre><code>    $r-&gt;add( &#39;/home&#39; =&gt; &#39;user#home&#39; );</code></pre>

</li>
<li><p>A code reference.</p>

<pre><code>    $r-&gt;add( &#39;/system&#39; =&gt; sub { return \%ENV } );</code></pre>

</li>
<li><p>A hashref with options.</p>

<pre><code>    # GET /item/100 -&gt; MyApp::Items::view
    $r-&gt;add(
        &#39;/item/:id&#39;, {
            to  =&gt; &#39;items#view&#39;,
            via =&gt; &#39;GET&#39;
        }
    );</code></pre>

<p>See <a href="#Destination-Options">&quot;Destination Options&quot;</a> for details.</p>

</li>
</ul>

<h3 id="Destination-Options">Destination Options</h3>

<p>There are a number of options you can add to modify the behavior of the route, if you specify a hashref for a destination:</p>

<h4 id="to">to</h4>

<p>Sets the destination for the route. It should be a subroutine name or CODE reference.</p>

<pre><code>    $r-&gt;add( &#39;/user&#39; =&gt; { to =&gt; &#39;users#home&#39; } ); # /home -&gt; MyApp::Users::home
    $r-&gt;add( &#39;/sys&#39; =&gt; { to =&gt; sub { ... } });    # /sys -&gt; execute code
    $r-&gt;add( &#39;/item&#39; =&gt; { to =&gt; &#39;Items::handle&#39; } ) ;   # /item -&gt; MyApp::Items::handle
    $r-&gt;add( &#39;/item&#39; =&gt; { to =&gt; &#39;Items::handle&#39; } );    # Same as above</code></pre>

<h4 id="via">via</h4>

<p>Specifies an HTTP method to be considered by <a href="#match">&quot;match&quot;</a> when matching a route.</p>

<pre><code>    # POST /item -&gt; MyApp::Items::add
    $r-&gt;add(
        &#39;/item&#39; =&gt; {
            via =&gt; &#39;POST&#39;,
            to  =&gt; &#39;items#add&#39;
        }
    );</code></pre>

<p>A shortcut for the above is this:</p>

<pre><code>    $r-&gt;add( [ POST =&gt; &#39;/item&#39; ] =&gt; &#39;items#add&#39; );</code></pre>

<h4 id="name">name</h4>

<p>Give the route a name, and you can always use it to build a URL later via the <a href="#url">&quot;url&quot;</a> subroutine.</p>

<pre><code>    $r-&gt;add(
        &#39;/item/:id/:name&#39; =&gt; {
            to   =&gt; &#39;items#view&#39;,
            name =&gt; &#39;item&#39;
        }
    );

    # Later
    $r-&gt;url( &#39;item&#39;, id =&gt; 8, name =&gt; &#39;foo&#39; );    # /item/8/foo</code></pre>

<h4 id="check">check</h4>

<p>A hashref of checks to perform on the captures. It should contain capture names and stringified regular expressions. Do not use <code>^</code> and <code>$</code> to denote beginning and ending of the matched expression, because it will get embedded in a bigger Regexp.</p>

<pre><code>    $r-&gt;add(
        &#39;/item/:id/:name&#39; =&gt; {
            to    =&gt; &#39;items#view&#39;,
            check =&gt; {
                id   =&gt; &#39;\d+&#39;,          # id must be a digit
                name =&gt; &#39;open|close&#39;    # name can be &#39;open&#39; or &#39;close&#39;
            }
          }
    );</code></pre>

<h4 id="defaults">defaults</h4>

<p>Set default values for optional placeholders.</p>

<pre><code>    $r-&gt;add(
        &#39;/pages/?id&#39; =&gt; {
            to       =&gt; &#39;pages#view&#39;,
            defaults =&gt; { id =&gt; 2 }
        }
    );

    # /pages    -&gt; match ( id = 2 )
    # /pages/   -&gt; match ( id = 2 )
    # /pages/4  -&gt; match ( id = 4 )</code></pre>

<h4 id="bridge">bridge</h4>

<p>If set to one this route will be treated as a bridge. Please see <a href="#bridges">&quot;bridges&quot;</a> for more information.</p>

<h4 id="tree">tree</h4>

<p>Creates a tree of sub-routes. See <a href="#trees">&quot;trees&quot;</a> for more information and examples.</p>

<h2 id="match">match</h2>

<p>Returns an array of <a>Kelp::Routes::Pattern</a> objects that match the path and HTTP method provided. Each object will contain a hash with the named placeholders in <a>&quot;named&quot; in Kelp::Routes::Pattern</a>, and an array with their values in the order they were specified in the pattern in <a>&quot;param&quot; in Kelp::Routes::Pattern</a>.</p>

<pre><code>    $r-&gt;add( &#39;/:id/:name&#39;, &quot;route&quot; );
    for my $pattern ( @{ $r-&gt;match(&#39;/15/alex&#39;) } ) {
        $pattern-&gt;named;    # { id =&gt; 15, name =&gt; &#39;alex&#39; }
        $pattern-&gt;param;    # [ 15, &#39;alex&#39; ]
    }</code></pre>

<p>Routes that used regular expressions instead of patterns will only initialize the <code>param</code> array with the regex captures, unless those patterns are using named captures in which case the <code>named</code> hash will also be initialized.</p>

<h1 id="ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</h1>

<p>This module was inspired by <a>Routes::Tiny</a>.</p>


</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#ATTRIBUTES">ATTRIBUTES</a>
    <ul>
      <li><a href="#pattern">pattern</a></li>
      <li><a href="#via">via</a></li>
      <li><a href="#name">name</a></li>
      <li><a href="#check">check</a></li>
      <li><a href="#defaults">defaults</a></li>
      <li><a href="#bridge">bridge</a></li>
      <li><a href="#regex">regex</a></li>
      <li><a href="#named">named</a></li>
      <li><a href="#param">param</a></li>
      <li><a href="#to">to</a></li>
    </ul>
  </li>
  <li><a href="#METHODS">METHODS</a>
    <ul>
      <li><a href="#match">match</a></li>
      <li><a href="#build-build-args-">build <code>build( %args )</code></a></li>
    </ul>
  </li>
  <li><a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Kelp::Routes::Pattern - Route patterns for Kelp routes</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    my $p = Kelp::Routes::Pattern-&gt;new( pattern =&gt; &#39;/:name/:place&#39; );
    if ( $p-&gt;match(&#39;/james/london&#39;) ) {
        %named = %{ $p-&gt;named };    # ( name =&gt; &#39;james&#39;, place =&gt; &#39;london&#39; )
        @param = @{ $p-&gt;param };    # ( &#39;james&#39;, &#39;london&#39; )
    }</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module is needed by <a>Kelp::Routes</a>. It provides matching for individual route patterns, returning the named placeholders in a hash and an array.</p>

<h1 id="ATTRIBUTES">ATTRIBUTES</h1>

<h2 id="pattern">pattern</h2>

<p>The pattern to match against. Each pattern is a string, which may contain named placeholders. For more information on the types and use of placeholders, look at <a>&quot;PLACEHOLDERS&quot; in Kelp::Routes</a>.</p>

<pre><code>    my $p = Kelp::Routes::Patters-&gt;new( pattern =&gt; &#39;/:id/*other&#39; );
    ...
    $p-&gt;match(&#39;/4/something-else&#39;);    # True</code></pre>

<h2 id="via">via</h2>

<p>Specifies an HTTP method to be matched by the route.</p>

<pre><code>    my $p = Kelp::Routes::Patters-&gt;new(
        pattern =&gt; &#39;/:id/*other&#39;,
        via     =&gt; &#39;PUT&#39;
    );

    $p-&gt;match(&#39;/4/something-else&#39;, &#39;GET&#39;);    # False. Only PUT allowed.</code></pre>

<h2 id="name">name</h2>

<p>You are encouraged to give each route a name, so you can look it up later when you build a URL for it.</p>

<pre><code>    my $p = Kelp::Routes::Patters-&gt;new(
        pattern =&gt; &#39;/:id/*other&#39;,
        name    =&gt; &#39;other_id&#39;
    );
    ...

    say $p-&gt;build( &#39;other_id&#39;, id =&gt; &#39;100&#39;, other =&gt; &#39;something-else&#39; );
    # Prints &#39;/100/something-else&#39;</code></pre>

<p>If no name is provided for the route, the <code>pattern</code> is used.</p>

<h2 id="check">check</h2>

<p>A hashref with placeholder names as keys and regular expressions as values. It is used to match the values of the placeholders against the provided regular expressions.</p>

<pre><code>    my $p = Kelp::Routes::Patters-&gt;new(
        pattern =&gt; &#39;/:id/*other&#39;,
        check   =&gt; { id =&gt; qr/\d+/ }    # id may only be a didgit
    );

    $p-&gt;match(&#39;/4/other&#39;);    # True
    $p-&gt;match(&#39;/q/other&#39;);    # False</code></pre>

<p>Note: Do not add <code>^</code> at the beginning or <code>$</code> at the end of the regular expressions, because they are merged into a bigger regex.</p>

<h2 id="defaults">defaults</h2>

<p>A hashref with placeholder defaults. This only applies to optional placeholders, or those prefixed with a question mark. If a default value is provided for any of them, it will be used in case the placeholder value is missing.</p>

<pre><code>    my $p = Kelp::Routes::Patters-&gt;new(
        pattern  =&gt; &#39;/:id/?other&#39;,
        defaults =&gt; { other =&gt; &#39;info&#39; }
    );

    $p-&gt;match(&#39;/100&#39;);
    # $p-&gt;named will contain { id =&gt; 100, other =&gt; &#39;info&#39; }

    $p-&gt;match(&#39;/100/delete&#39;);
    # $p-&gt;named will contain { id =&gt; 100, other =&gt; &#39;delete&#39; }</code></pre>

<h2 id="bridge">bridge</h2>

<p>A True/False value. Specifies if the route is a bridge. For more information about bridges, please see <a>&quot;BRIDGES&quot; in Kelp::Routes</a></p>

<h2 id="regex">regex</h2>

<p>We recommend that you stick to using patterns, because they are simpler and easier to read, but if you need to match a really complicated route, then you can use a regular expression.</p>

<pre><code>    my $p = Kelp::Routes::Patters-&gt;new( regex =&gt; qr{^(\d+)/(\d+)$} );
    $p-&gt;match(&#39;/100/200&#39;);  # True. $p-&gt;param will be [ 100, 200 ]</code></pre>

<p>After matching, the <a href="#param">&quot;param&quot;</a> array will be initialized with the values of the captures in the order they appear in the regex. If you used a regex with named captures, then a hashref <a href="#named">&quot;named&quot;</a> will also be initialized with the names and values of the named placeholders. In other words, this hash will be a permanent copy of the <code>%+</code> built-in hash.</p>

<pre><code>    my $p = Kelp::Routes::Patters-&gt;new( regex =&gt; qr{^(?&lt;id&gt;\d+)/(?&lt;line&gt;\d+)$} );
    $p-&gt;match(&#39;/100/200&#39;);  # True.
                            # $p-&gt;param will be [ 100, 200 ]
                            # $p-&gt;named will be { id =&gt; 100, line =&gt; 200 }</code></pre>

<p>If <code>regex</code> is not explicitly given a value it will be built from the <code>pattern</code>.</p>

<h2 id="named">named</h2>

<p>A hashref which will be initialized by the <a href="#match">&quot;match&quot;</a> function. After matching, it will contain placeholder names and values for the matched route.</p>

<h2 id="param">param</h2>

<p>An arrayref, which will be initialized by the <a href="#match">&quot;match&quot;</a> function. After matching, it will contain all placeholder values in the order they were specified in the pattern.</p>

<h2 id="to">to</h2>

<p>Specifies the route destination. See examples in <a>Kelp::Routes</a>.</p>

<h1 id="METHODS">METHODS</h1>

<h2 id="match">match</h2>

<p><code>match( $path, $method )</code></p>

<p>Matches an already initialized route against a path and http method. If the match was successful, this sub will return a true value and the <a href="#named">&quot;named&quot;</a> and <a href="#param">&quot;param&quot;</a> attributes will be initialized with the names and values of the matched placeholders.</p>

<h2 id="build-build-args-">build <code>build( %args )</code></h2>

<p>Builds a URL from a pattern.</p>

<pre><code>    my $p = Kelp::Routes::Patters-&gt;new( pattern  =&gt; &#39;/:id/:line/:row&#39; );
    $p-&gt;build( id =&gt; 100, line =&gt; 5, row =&gt; 8 ); # Returns &#39;/100/5/8&#39;</code></pre>

<h1 id="ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</h1>

<p>This module was inspired by <a>Routes::Tiny</a>.</p>

<p>The concept of bridges was borrowed from <a>Mojolicious</a></p>


</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#WHY-">WHY?</a></li>
  <li><a href="#USAGE">USAGE</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Kelp::Base - Simple lazy attributes</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    use Kelp::Base;

    attr source =&gt; &#39;dbi:mysql:users&#39;;
    attr user   =&gt; &#39;test&#39;;
    attr pass   =&gt; &#39;secret&#39;;
    attr opts   =&gt; { PrintError =&gt; 1, RaiseError =&gt; 1 };

    attr dbh =&gt; sub {
        my $self = shift;
        DBI-&gt;connect( $self-&gt;sourse, $self-&gt;user, $self-&gt;pass, $self-&gt;opts );
    };

    # Later ...
    sub do_stuff {
        my $self = shift;
        $self-&gt;dbh-&gt;do(&#39;DELETE FROM accounts&#39;);
    }</code></pre>

<p>or</p>

<pre><code>    use Kelp::Base &#39;Module::Name&#39;;    # Extend Module::Name</code></pre>

<p>or</p>

<pre><code>    use Kelp::Base -strict;    # Only use strict, warnings and v5.10
                                  # No magic</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module provides simple lazy attributes.</p>

<h1 id="WHY-">WHY?</h1>

<p>Some users will naturally want to ask <i>&quot;Why not use Moose/Mouse/Moo/Mo?&quot;</i>. The answer is that the Kelp web framework needs lazy attributes, but the author wanted to keep the code light and object manager agnostic. This allows the users of the framework to choose an object manager to their liking. There is nothing more annoying than a module that forces you to use <a>Moose</a> when you are perfectly fine with <a>Moo</a> or <a>Mo</a>, for example.</p>

<h1 id="USAGE">USAGE</h1>

<pre><code>    use Kelp::Base;</code></pre>

<p>The above will automatically include <code>strict</code>, <code>warnings</code> and <code>v5.10</code>. It will also inject a new sub in the current class called <code>attr</code>.</p>

<pre><code>    attr name1 =&gt; 1;         # Fixed value
    attr name2 =&gt; [1,2,3];   # Array
    attr name3 =&gt; sub {
        $_[0]-&gt;other
    }

    ...

    say $self-&gt;name1;               # 1
    $self-&gt;name2( [ 6, 7, 8 ] );    # Set new value</code></pre>

<p>All those attributes will be available for reading and writing in each instance of the current class. If you want to create a read-only attribute, prefix its name with a dash.</p>

<pre><code>    attr -readonly =&gt; &quot;something&quot;;

    # Later
    say $self-&gt;readonly;           # something
    $self-&gt;readonly(&quot;nothing&quot;);    # no change</code></pre>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a>Kelp</a>, <a>Moose</a>, <a>Moo</a>, <a>Mo</a>, <a>Any::Moose</a></p>


</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Registering-methods">Registering methods</a></li>
      <li><a href="#Passing-arguments-to-your-module">Passing arguments to your module</a></li>
    </ul>
  </li>
  <li><a href="#METHODS">METHODS</a>
    <ul>
      <li><a href="#build">build</a></li>
      <li><a href="#register">register</a></li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Kelp::Module - Base class for Kelp modules</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    package Kelp::Module::MyModule;
    use parent &#39;Kelp::Module&#39;;

    sub build {
        my ( $self, %args ) = @_;
        $self-&gt;register( greet =&gt; sub { print &quot;Hi there.&quot; } );
    }</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Provides the base class for creating Kelp modules. Creating a Kelp module means extending this class and overriding the <code>build</code> method. Kelp modules usually <code>register</code> a new method into the web application.</p>

<h2 id="Registering-methods">Registering methods</h2>

<p>Modules use the <a href="#register">&quot;register&quot;</a> method to register new methods into the underlying web application. All the registrations are done in the <a href="#build">&quot;build&quot;</a> subroutine. All types of values can be registered and then accessed as a read-only attribute from the web app. The simplest thing you can register is a scalar value:</p>

<p>First...</p>

<pre><code>    # lib/Kelp/Module/Month.pm
    package Kelp::Module::Month;
    use Kelp::Base &#39;Kelp::Module&#39;;

    sub build {
        my ( $self, %args ) = @_;
        $self-&gt;register( month =&gt; &#39;October&#39; );
    }</code></pre>

<p>Then ...</p>

<pre><code>    # lib/MyApp.pm
    package MyApp;
    use parent &#39;Kelp&#39;;

    sub build {
        $self-&gt;load_module(&quot;Month&quot;);
    }

    sub is_it_october_yet {
        my $self = shift;
        if ( $self-&gt;month eq &#39;October&#39; ) {
            return &quot;It is October&quot;;
        }
        return &quot;Not yet.&quot;;
    }</code></pre>

<p>The above example doesn&#39;t do anything meaningful, but it&#39;s a good way to show how to create and use Kelp modules. Pay attention to the next example, as it will show you how to register an anonymous subroutine:</p>

<pre><code>    package Kelp::Module::Date;
    use Kelp::Base &#39;Kelp::Module&#39;;
    use DateTime;

    sub build {
        my ( $self, %args ) = @_;
        $self-&gt;register(
            date =&gt; sub {
                return DateTime-&gt;from_epoch( epoch =&gt; time );
            }
        );
    }</code></pre>

<p>Now, each time you use <code>$self-&gt;date</code> in the web application, you will create a new <code>DateTime</code> object for the current time.</p>

<p>It is more practical to register an already created object. Consider this example, which uses <code>Redis</code>, initializes an instance of it and registers it as a method in the web app:</p>

<pre><code>    package Kelp::Module::Redis;
    use Kelp::Base &#39;Kelp::Module&#39;;
    use Redis;

    sub build {
        my ( $self, %args ) = @_;
        my $redis = Redis-&gt;new(%args);
        $self-&gt;register( redis =&gt; $redis );
    }</code></pre>

<h2 id="Passing-arguments-to-your-module">Passing arguments to your module</h2>

<p>The arguments for all modules are taken from the configuration. If you want to pass arguments for your <code>Redis</code> module (example above), you will have to have a structure in your config, similar to this:</p>

<p>Example of <code>conf/myapp.conf</code>:</p>

<pre><code>    {
        # Load module Redis on start
        modules      =&gt; [&#39;Redis&#39;],
        modules_init =&gt; {
            Redis =&gt; {
                server   =&gt; &#39;192.168.0.1:6379&#39;,
                encoding =&gt; &#39;UTF-8&#39;,
                password =&gt; &#39;boo&#39;
            }
        }
    };</code></pre>

<p>The hash specified by <code>Redis</code> will be sent as <code>%args</code> in the <code>build</code> method of the module.</p>

<h1 id="METHODS">METHODS</h1>

<h2 id="build">build</h2>

<p><code>build( %args )</code></p>

<p>Each module must override this one in order to register new methods. The <code>%args</code> hash will be taken from the configuration.</p>

<h2 id="register">register</h2>

<p><code>register( %items )</code></p>

<p>Register one or many methods into the web application.</p>

<pre><code>    $self-&gt;register(
        json =&gt; JSON-&gt;new,
        yaml =&gt; YAML-&gt;new
    );</code></pre>


</body>

</html>


<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#MANUAL">MANUAL</a>
    <ul>
      <li><a href="#Kelp::Manual::Main"><a>Kelp::Manual::Main</a></a></li>
      <li><a href="#Kelp::Manual::Less"><a>Kelp::Manual::Less</a></a></li>
    </ul>
  </li>
  <li><a href="#SUPPORT">SUPPORT</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#LICENSE">LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Kelp - A web framework light, yet rich in nutrients.</p>

<h1 id="MANUAL">MANUAL</h1>

<h2 id="Kelp::Manual::Main"><a>Kelp::Manual::Main</a></h2>

<p>Main manual.</p>

<h2 id="Kelp::Manual::Less"><a>Kelp::Manual::Less</a></h2>

<p>Information on using <code>Kelp::Less</code>.</p>

<h1 id="SUPPORT">SUPPORT</h1>

<ul>

<li><p>GitHub: https://github.com/naturalist/kelp</p>

</li>
<li><p>Mailing list: https://groups.google.com/forum/?fromgroups#!forum/perl-kelp</p>

</li>
</ul>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Stefan Geneshky - minimal@cpan.org</p>

<h1 id="LICENSE">LICENSE</h1>

<p>This module and all the modules in this package are governed by the same license as Perl itself.</p>


</body>

</html>


